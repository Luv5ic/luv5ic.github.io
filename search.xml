<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Fluent Python Study Notes</title>
    <url>/2021-01-21-Fluent-Python-Study-Notes/</url>
    <content><![CDATA[<h1 id="Python-数据模型"><a href="#Python-数据模型" class="headerlink" title="Python 数据模型"></a>Python 数据模型</h1><h2 id="一摞Python风格的纸牌"><a href="#一摞Python风格的纸牌" class="headerlink" title="一摞Python风格的纸牌"></a>一摞Python风格的纸牌</h2><blockquote>
<p>类中的函数称为方法，特殊方法，也叫魔术方法,与其他方法的差别在于调用方法的方式。比如 <code>__init__()</code>,每次根据类创建实例时，Python都会自动运行它。在这个方法的定义中，形参 self 必不可少，还必须位于其他形参的前面。当 Python调用这个方法来创建一个实例时，将自动传入实参 self 。每个与类相关联的方法调用都自动传递实参 self ，它是一个指向实例本身的引用，让实例能够访问类中的属性和方法。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 一摞有序的纸牌</span></span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line">Card = collections.namedtuple(<span class="string">&#x27;Card&#x27;</span>, [<span class="string">&#x27;rank&#x27;</span>, <span class="string">&#x27;suit&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrenchDeck</span>:</span></span><br><span class="line">    ranks = [<span class="built_in">str</span>(n) <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>,<span class="number">11</span>)] + <span class="built_in">list</span>(<span class="string">&#x27;JQKA&#x27;</span>)</span><br><span class="line">    suits = <span class="string">&#x27;spades diamonds clubs hearts&#x27;</span>.split()</span><br><span class="line"></span><br><span class="line">    def_init_(self):</span><br><span class="line">        self._cards = [Card(rank, suit) <span class="keyword">for</span> suit <span class="keyword">in</span> self.suits</span><br><span class="line">                                        <span class="keyword">for</span> rank <span class="keyword">in</span> self.ranks]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self._cards)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, position</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self._cards[position]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看一叠牌有多少张</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck = FrenchDeck()   <span class="comment"># 创建实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">len</span>(deck)</span><br><span class="line"><span class="number">52</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽取特定的一张纸牌</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">0</span>]</span><br><span class="line">Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[-<span class="number">1</span>]</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机抽取一张纸牌 random.choice</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> random <span class="keyword">import</span> choice</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)</span><br><span class="line">Card(rank=<span class="string">&#x27;3&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>choice(deck)</span><br><span class="line">Card(rank=<span class="string">&#x27;K&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片操作</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[:<span class="number">3</span>]</span><br><span class="line">[Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>), Card(rank=<span class="string">&#x27;3&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>),</span><br><span class="line">Card(rank=<span class="string">&#x27;4&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>deck[<span class="number">12</span>::<span class="number">13</span>]</span><br><span class="line">[Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>), Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;diamonds&#x27;</span>),</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;clubs&#x27;</span>), Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可迭代</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> deck:</span><br><span class="line"><span class="meta">... </span>  print(card)</span><br><span class="line">Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;3&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;4&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> <span class="built_in">reversed</span>(deck): <span class="comment"># 反向迭代</span></span><br><span class="line"><span class="meta">... </span>  print(card)</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;K&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;Q&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;hearts&#x27;</span>) <span class="keyword">in</span> deck</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Card(<span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;beasts&#x27;</span>) <span class="keyword">in</span> deck</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对这摞牌升序排序</span></span><br><span class="line">suit_values = <span class="built_in">dict</span>(spades=<span class="number">3</span>, hearts=<span class="number">2</span>, diamonds=<span class="number">1</span>, clubs=<span class="number">0</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">spades_high</span>(<span class="params">card</span>):</span></span><br><span class="line">    rank_value = FrenchDeck.ranks.index(card.rank)</span><br><span class="line">    <span class="keyword">return</span> rank_value * <span class="built_in">len</span>(suit_values) + suit_values[card.suit]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> card <span class="keyword">in</span> <span class="built_in">sorted</span>(deck, key=spades_high): </span><br><span class="line"><span class="meta">... </span>     print(card)</span><br><span class="line">Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;clubs&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;diamonds&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;2&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line"><span class="meta">... </span>(<span class="number">46</span> cards ommitted)</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;diamonds&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;hearts&#x27;</span>)</span><br><span class="line">Card(rank=<span class="string">&#x27;A&#x27;</span>, suit=<span class="string">&#x27;spades&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>collections.namedtuple 构建了一个名为 Card,只具有属性 rank 和 suit 的类。<br><code>__len__</code> 和 <code>__getitem__</code> 的具体实现可以代理给 self._cards这个 Python 列表（即 list 对象）。</p>
</blockquote>
<h2 id="如何使用特殊方法"><a href="#如何使用特殊方法" class="headerlink" title="如何使用特殊方法"></a>如何使用特殊方法</h2><ol>
<li>特殊方法是为了被 Python 解释器调用的，所以没有<code>my_object.__len__()</code>这种写法，而是<code>len(my_object)</code>。</li>
<li>如果不是自定义对象，而是 Python 内置类型，比如 list、str 等，Python 会直接调用一种内置的 ob_size 属性。</li>
<li>通过内置的函数（len、iter、str 等）来构造特殊方法最好。因为对于内置的类来说，速度更快。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 二维向量加法</span></span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> hypot</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x=<span class="number">0</span>, y=<span class="number">0</span></span>):</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;Vector(%r, %r)&#x27;</span> % (self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bool</span>(<span class="built_in">abs</span>(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        x = self.x + other.x</span><br><span class="line">        y = self.y + other.y</span><br><span class="line">        <span class="keyword">return</span> Vector(x, y)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__mul__</span>(<span class="params">self, scalar</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Vector(self.x * scalar, self.y * scalar)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v2 = Vector(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 + v2</span><br><span class="line">Vector(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v = Vector(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(v)</span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v * <span class="number">3</span></span><br><span class="line">Vector(<span class="number">9</span>, <span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(v * <span class="number">3</span>)</span><br><span class="line"><span class="number">15.0</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Python 有一个内置的函数叫 repr，它能把一个对象用字符串的形式表达出来以便辨认，这就是“字符串表示形式”。repr 就是通过<code>__repr__</code>这个特殊方法来得到一个对象的字符串表示形式的。如果没有实现<code>__repr__</code>，当我们在控制台里打印一个向量的实例时，得到的字符串可能会是 <code>&lt;Vector object at 0x10e100070&gt;</code>。</p>
</blockquote>
<h2 id="特殊方法一览"><a href="#特殊方法一览" class="headerlink" title="特殊方法一览"></a>特殊方法一览</h2><blockquote>
<p><a href="https://docs.python.org/3/reference/datamodel.html">Python 语言参考手册中的“DataModel”</a></p>
</blockquote>
<p>跟运算符无关的特殊方法：</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">方法名</th>
</tr>
</thead>
<tbody><tr>
<td align="left">字符串/字节序列表示形式</td>
<td align="left">__repr__ 、 __str__ 、 __format__ 、 __bytes__</td>
</tr>
<tr>
<td align="left">数值转换</td>
<td align="left">__abs__ 、 __bool__ 、 __complex__ 、 __int__ 、 __float__ 、 __hash__ 、 __index__</td>
</tr>
<tr>
<td align="left">集合模拟</td>
<td align="left">__len__ 、 __getitem__ 、 __setitem__ 、 __delitem__ 、 __contains__</td>
</tr>
<tr>
<td align="left">迭代枚举</td>
<td align="left">__iter__ 、 __reversed__ 、 __next__</td>
</tr>
<tr>
<td align="left">可调用模拟</td>
<td align="left">__call__</td>
</tr>
<tr>
<td align="left">上下文管理</td>
<td align="left">__enter__ 、 __exit__</td>
</tr>
<tr>
<td align="left">实例创建和销毁</td>
<td align="left">__new__ 、 __init__ 、 __del__</td>
</tr>
<tr>
<td align="left">属性管理</td>
<td align="left">__getattr__ 、 __getattribute__ 、 __setattr__ 、 __delattr__ 、 __dir__</td>
</tr>
<tr>
<td align="left">属性描述符</td>
<td align="left">__get__ 、 __set__ 、 __delete__</td>
</tr>
<tr>
<td align="left">跟类相关的服务</td>
<td align="left">__prepare__ 、 __instancecheck__ 、 __subclasscheck__</td>
</tr>
</tbody></table>
<p>跟运算符相关的特殊方法：</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">方法名和对应的运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一元运算符</td>
<td align="left">__neg__ - 、 __pos__ + 、 __abs__ abs()</td>
</tr>
<tr>
<td align="left">众多比较运算符</td>
<td align="left">__lt__ &lt; 、 __le__ &lt;= 、 __eq__ == 、 __ne__ != 、 __gt__ &gt; 、 __ge__ &gt;=</td>
</tr>
<tr>
<td align="left">算术运算符</td>
<td align="left">__add__ + 、 __sub__ - 、 __mul__ * 、 __truediv__ / 、 __floordiv__ // 、 __mod__ % 、 __divmod__ divmod() 、 __pow__ ** 或 pow() 、 __round__ round()</td>
</tr>
<tr>
<td align="left">反向算术运算符</td>
<td align="left">__radd__ 、 __rsub__ 、 __rmul__ 、 __rtruediv__ 、 __rfloordiv__ 、 __rmod__ 、  __rdivmod__ 、 __rpow__</td>
</tr>
<tr>
<td align="left">增量赋值算术运算符</td>
<td align="left">__iadd__ 、 __isub__ 、 __imul__ 、 __itruediv__ 、 __ifloordiv__ 、 __imod__ 、 __ipow__</td>
</tr>
<tr>
<td align="left">位运算符</td>
<td align="left">__invert__ ~ 、 __lshift__ &lt;&lt; 、 __rshift__ &gt;&gt; 、 __and__ &amp; 、 __or__</td>
</tr>
<tr>
<td align="left">反向位运算符</td>
<td align="left">__rlshift__ 、 __rrshift__ 、 __rand__ 、 __rxor__ 、 __ror__</td>
</tr>
<tr>
<td align="left">增量赋值位算术运算符</td>
<td align="left">__ilshift__ 、 __irshift__ 、 __iand__ 、 __ixor__ 、 __ior__</td>
</tr>
</tbody></table>
<h1 id="序列构成的数组"><a href="#序列构成的数组" class="headerlink" title="序列构成的数组"></a>序列构成的数组</h1><h2 id="内置序列类型概览"><a href="#内置序列类型概览" class="headerlink" title="内置序列类型概览"></a>内置序列类型概览</h2><ul>
<li>容器序列：list、tuple 和 collections.deque 这些序列能存放不同类型的数据</li>
<li>扁平序列：str、bytes、bytearray、memoryview 和 array.array，这类序列只能容纳一种类型</li>
<li>可变序列：list、bytearray、array.array、collections.deque、memoryview</li>
<li>不可变序列：tuple、str 和 bytes<br><img src="../images/2021-03-12-14-36-43.png"><blockquote>
<p>可变序列（MutableSequence）和不可变序列（Sequence）</p>
</blockquote>
</li>
</ul>
<h2 id="列表推导和生成器表达式"><a href="#列表推导和生成器表达式" class="headerlink" title="列表推导和生成器表达式"></a>列表推导和生成器表达式</h2><p>虽然也可以用列表推导来初始化元组、数组或其他序列类型，但是生成器表达式是更好的选择。这是因为生成器表达式背后遵守了迭代器协议，可以逐个地产出元素，而不是先建立一个完整的列表，然后再把这个列表传递到某个构造函数里。前面那种方式显然能够节省内存。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字符串变成 Unicode 码位</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes = [<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols]    <span class="comment"># 列表推导</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>codes</span><br><span class="line">[<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii = [<span class="built_in">ord</span>(s) <span class="keyword">for</span> s <span class="keyword">in</span> symbols <span class="keyword">if</span> <span class="built_in">ord</span>(s) &gt; <span class="number">127</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii</span><br><span class="line">[<span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> c: c &gt; <span class="number">127</span>, <span class="built_in">map</span>(<span class="built_in">ord</span>, symbols)))         <span class="comment">#    filter和map</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>beyond_ascii</span><br><span class="line">[<span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>symbols = <span class="string">&#x27;$¢£¥€¤&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">tuple</span>(<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)  <span class="comment"># 生成器表达式</span></span><br><span class="line">(<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> array</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>array.array(<span class="string">&#x27;I&#x27;</span>, (<span class="built_in">ord</span>(symbol) <span class="keyword">for</span> symbol <span class="keyword">in</span> symbols)) </span><br><span class="line">array(<span class="string">&#x27;I&#x27;</span>, [<span class="number">36</span>, <span class="number">162</span>, <span class="number">163</span>, <span class="number">165</span>, <span class="number">8364</span>, <span class="number">164</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用生成器表达式计算笛卡尔积</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>colors = [<span class="string">&#x27;black&#x27;</span>, <span class="string">&#x27;white&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sizes = [<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;L&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> tshirt <span class="keyword">in</span> (<span class="string">&#x27;%s %s&#x27;</span> % (c, s) <span class="keyword">for</span> c <span class="keyword">in</span> colors <span class="keyword">for</span> s <span class="keyword">in</span> sizes): </span><br><span class="line"><span class="meta">... </span>    print(tshirt)</span><br><span class="line">...</span><br><span class="line">black S</span><br><span class="line">black M</span><br><span class="line">black L</span><br><span class="line">white S</span><br><span class="line">white M</span><br><span class="line">white L</span><br></pre></td></tr></table></figure>
<blockquote>
<p>表达式内部的变量和赋值只在局部起作用，表达式的上下文里的同名变量还可以被正常引用。</p>
</blockquote>
]]></content>
      <categories>
        <category>Study Notes</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Study Notes</tag>
      </tags>
  </entry>
  <entry>
    <title>Nowcoder_SQL_Practice</title>
    <url>/2021-01-03-Nowcoder_SQL_Practice/</url>
    <content><![CDATA[<h1 id="牛客每个人最近的登录日期-1-0"><a href="#牛客每个人最近的登录日期-1-0" class="headerlink" title="牛客每个人最近的登录日期 1.0"></a>牛客每个人最近的登录日期 1.0</h1><h2 id="description"><a href="#description" class="headerlink" title="description"></a>description</h2><p>牛客每天有很多人登录，请你统计一下牛客每个用户最近登录是哪一天，用的是什么设备.</p>
<p><strong>login记录表</strong>，简况如下:</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">user_id</th>
<th align="center">client_id</th>
<th align="center">date</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2020-10-14</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2020-10-14</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2020-10-15</td>
</tr>
</tbody></table>
<p><strong>user表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">tm</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">fh</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">wangchao</td>
</tr>
</tbody></table>
<p><strong>client表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">u_n</th>
<th align="center">c_n</th>
<th align="center">date</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fh</td>
<td align="center">ios</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">wangchao</td>
<td align="center">ios</td>
<td align="center">2020-10-13</td>
</tr>
</tbody></table>
<h1 id="牛客每个人最近的登录日期-5-0"><a href="#牛客每个人最近的登录日期-5-0" class="headerlink" title="牛客每个人最近的登录日期 5.0"></a>牛客每个人最近的登录日期 5.0</h1><h2 id="description-1"><a href="#description-1" class="headerlink" title="description"></a>description</h2><p>统计牛客每个日期新用户的次日留存率。</p>
<p><strong>login表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">user_id</th>
<th align="center">client_id</th>
<th align="center">date</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2020-10-14</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2020-10-14</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">2020-10-15</td>
</tr>
</tbody></table>
<h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><ul>
<li>每个日期的新用户数<ul>
<li>先求一个日期的新用户数:找到用户A对应的所有日期，最小的日期B就是用户第一次登陆的日期，即日期B的新用户就是用户A。<strong>自连接查询</strong>。</li>
<li>再联立主表，得到每个日期的新用户数<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- first_login:</span></span><br><span class="line"><span class="keyword">select</span> login.date, ifnull(n1.new_num,<span class="number">0</span>) first_num</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> l1.date, <span class="built_in">count</span>(<span class="keyword">distinct</span> l1.user_id) new_num</span><br><span class="line"><span class="keyword">from</span> login l1</span><br><span class="line"><span class="keyword">where</span> l1.date <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">min</span>(<span class="type">date</span>) <span class="keyword">from</span> login <span class="keyword">where</span> user_id <span class="operator">=</span> l1.user_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> l1.date) n1</span><br><span class="line"><span class="keyword">on</span> login.date <span class="operator">=</span> n1.date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> login.date;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>每个日期新用户次日还登陆的用户数<ul>
<li>得到日期B的新用户数后，再去查找基于日期B用户A的记录上，用户A的对应日期为日期B后一天的记录。也就是这两条记录主键是用户A，日期满足后一天的条件。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- second_login:</span></span><br><span class="line"><span class="keyword">select</span> login.date, ifnull(n2.second_num,<span class="number">0</span>) second_num</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> l1.date, <span class="built_in">count</span>(<span class="keyword">distinct</span> l1.user_id) second_num</span><br><span class="line"><span class="keyword">from</span> login  l1 </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> login l2</span><br><span class="line"><span class="keyword">on</span> l1.id <span class="operator">=</span> l2.id <span class="keyword">and</span> l2.date <span class="operator">=</span> adddate(l1.date, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="keyword">where</span> l1.date <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">min</span>(<span class="type">date</span>) <span class="keyword">from</span> login <span class="keyword">where</span> user_id <span class="operator">=</span> l1.user_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> l1.date) n2</span><br><span class="line"><span class="keyword">on</span> login.date <span class="operator">=</span> n2.date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> login.date;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>联立这两个表，注意 second_login 表应为主表。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> second_login.date, round(ifnull(second_login.second_num <span class="operator">*</span><span class="number">1.0</span><span class="operator">/</span> first_login.first_num,<span class="number">0</span>),<span class="number">3</span>) p</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> login.date, ifnull(n2.second_num,<span class="number">0</span>) second_num</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> l1.date, <span class="built_in">count</span>(<span class="keyword">distinct</span> l1.user_id) second_num</span><br><span class="line"><span class="keyword">from</span> login  l1 </span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> login l2</span><br><span class="line"><span class="keyword">on</span> l1.id <span class="operator">=</span> l2.id <span class="keyword">and</span> l2.date <span class="operator">=</span> adddate(l1.date, <span class="type">interval</span> <span class="number">1</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="keyword">where</span> l1.date <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">min</span>(<span class="type">date</span>) <span class="keyword">from</span> login <span class="keyword">where</span> user_id <span class="operator">=</span> l1.user_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> l1.date) n2</span><br><span class="line"><span class="keyword">on</span> login.date <span class="operator">=</span> n2.date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> login.date) second_login</span><br><span class="line"><span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> login.date, ifnull(n1.new_num,<span class="number">0</span>) first_num</span><br><span class="line"><span class="keyword">from</span> login</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span></span><br><span class="line">(<span class="keyword">select</span> l1.date, <span class="built_in">count</span>(<span class="keyword">distinct</span> l1.user_id) new_num</span><br><span class="line"><span class="keyword">from</span> login l1</span><br><span class="line"><span class="keyword">where</span> l1.date <span class="operator">=</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="built_in">min</span>(<span class="type">date</span>) <span class="keyword">from</span> login <span class="keyword">where</span> user_id <span class="operator">=</span> l1.user_id)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> l1.date) n1</span><br><span class="line"><span class="keyword">on</span> login.date <span class="operator">=</span> n1.date</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> login.date) first_login</span><br><span class="line"><span class="keyword">on</span> second_login.date<span class="operator">=</span>first_login.date;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="牛客每个人最近的登录日期-6-0"><a href="#牛客每个人最近的登录日期-6-0" class="headerlink" title="牛客每个人最近的登录日期 6.0"></a>牛客每个人最近的登录日期 6.0</h1><h2 id="description-2"><a href="#description-2" class="headerlink" title="description"></a>description</h2><p>统计牛客每个用户的刷题信息。</p>
<p><strong>login表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">user_id</th>
<th align="center">client_id</th>
<th align="center">date</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">1</td>
<td align="center">3</td>
<td align="center">2020-10-13</td>
</tr>
</tbody></table>
<p><strong>passing_number表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">user_id</th>
<th align="center">number</th>
<th align="center">date</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">4</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">2020-10-12</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">2020-10-13</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">2020-10-13</td>
</tr>
</tbody></table>
<p><strong>user表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">tm</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">fh</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">wangchao</td>
</tr>
</tbody></table>
<p><strong>输出表</strong>如下，包括：用户姓名，截止到某天，累计通过了多少题，查询结果先按照日期升序排序，再按照姓名升序排序。不包括登陆但未刷题的记录。</p>
<table>
<thead>
<tr>
<th align="center">u_n</th>
<th align="center">date</th>
<th align="center">ps_num</th>
</tr>
</thead>
<tbody><tr>
<td align="center">fh</td>
<td align="center">2020-10-12</td>
<td align="center">4</td>
</tr>
<tr>
<td align="center">wangchao</td>
<td align="center">2020-10-12</td>
<td align="center">1</td>
</tr>
<tr>
<td align="center">tm</td>
<td align="center">2020-10-13</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">wangchao</td>
<td align="center">2020-10-13</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h2 id="key-1"><a href="#key-1" class="headerlink" title="key"></a>key</h2><p>首先，不需要登陆但未刷题的记录，所以不需要 login 表。</p>
<ul>
<li><strong>窗口函数</strong>，将数据按照 user_id 分组，date 排序，在每个分区内计算每一行的刷题总数。</li>
<li>与 user 表联立查询得到结果。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name u_n, <span class="type">date</span>, <span class="built_in">sum</span>(number) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>) ps_num  <span class="comment">-- 因为是求累计结果，所以按照日期排序很关键</span></span><br><span class="line"><span class="keyword">from</span> passing_number pn</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">user</span></span><br><span class="line"><span class="keyword">on</span> pn.user_id <span class="operator">=</span> user.id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>, name;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="考试分数-1-0"><a href="#考试分数-1-0" class="headerlink" title="考试分数 1.0"></a>考试分数 1.0</h1><h2 id="description-3"><a href="#description-3" class="headerlink" title="description"></a>description</h2><p>每个用户参加相关语言岗位的笔试后会有不同的分数。<br><strong>grade表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">language_id</th>
<th align="center">grade</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">12000</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">1</td>
<td align="center">13000</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">11000</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">2</td>
<td align="center">10000</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">3</td>
<td align="center">11000</td>
</tr>
<tr>
<td align="center">6</td>
<td align="center">1</td>
<td align="center">11000</td>
</tr>
<tr>
<td align="center">7</td>
<td align="center">2</td>
<td align="center">11000</td>
</tr>
</tbody></table>
<p>不同语言岗位 <strong>language表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">C++</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">JAVA</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Python</td>
</tr>
</tbody></table>
<p><strong>输出表</strong>如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">name</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">C++</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">JAVA</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">Python</td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="key-2"><a href="#key-2" class="headerlink" title="key"></a>key</h2><ul>
<li>利用窗口函数，得到按 language 分组的区间重复不间断排序</li>
<li>再联立表得到 language 的 name，筛选出名次为第1和第2名的记录。<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.id, l.name, t1.score</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(<span class="keyword">select</span> <span class="operator">*</span>, <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> language_id <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>) ranking</span><br><span class="line"><span class="keyword">from</span> grade) t1</span><br><span class="line"><span class="keyword">join</span> <span class="keyword">language</span> l </span><br><span class="line"><span class="keyword">on</span> t1.language_id <span class="operator">=</span> l.id</span><br><span class="line"><span class="keyword">where</span> t1.ranking <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> t1.ranking <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> l.name, t1.score <span class="keyword">desc</span>, t1.id;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>other</strong><br>主要思路是利用自连接得到排序值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.id, name, score</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> g1</span><br><span class="line">    <span class="keyword">from</span> grade g1, grade g2</span><br><span class="line">    <span class="keyword">where</span> g1.score <span class="operator">&lt;=</span> g2.score</span><br><span class="line">    <span class="keyword">and</span> g1.language_id <span class="operator">=</span> g2.language_id</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> g1.language_id, g1.id</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> g2.score) <span class="operator">&lt;=</span> <span class="number">2</span>) t1</span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> <span class="keyword">language</span></span><br><span class="line"><span class="keyword">on</span> t1.language_id <span class="operator">=</span> language.id</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> name, score <span class="keyword">desc</span>, t1.id;</span><br></pre></td></tr></table></figure>
<h1 id="考试分数-2-0"><a href="#考试分数-2-0" class="headerlink" title="考试分数 2.0"></a>考试分数 2.0</h1><h2 id="description-4"><a href="#description-4" class="headerlink" title="description"></a>description</h2><p><strong>grade表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">job</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">C++</td>
<td align="center">11001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C++</td>
<td align="center">10000</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">C++</td>
<td align="center">9000</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Java</td>
<td align="center">12000</td>
</tr>
</tbody></table>
<p>查询各个岗位分数升序排列之后的中位数位置的范围，并且按job升序排序，结果如下:</p>
<p>|job|start|end|<br>|B|2|2|<br>|C++|2|2|<br>|Java|1|2|</p>
<p>第1行表示C++岗位的中位数位置范围为[2,2]，也就是2。因为C++岗位总共3个人，是奇数，所以中位数位置为2是正确的(即位置为2的10000是中位数)<br>第2行表示Java岗位的中位数位置范围为[1,2]。因为Java岗位总共2个人，是偶数，所以中位数位置为[1,2]是正确的(即需要知道位置为1的12000与位置为2的13000才能计算出中位数为12500</p>
<h2 id="key-3"><a href="#key-3" class="headerlink" title="key"></a>key</h2><p>常规思路就是先判断奇偶。<br><strong>best</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> job,</span><br><span class="line">    <span class="built_in">floor</span>((<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">+</span> <span class="number">1</span>) <span class="operator">/</span> <span class="number">2</span>) <span class="keyword">start</span>,</span><br><span class="line">    <span class="built_in">floor</span>((<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">+</span> <span class="number">2</span>) <span class="operator">/</span> <span class="number">2</span>) <span class="keyword">end</span></span><br><span class="line"><span class="keyword">from</span> grade</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> job;</span><br></pre></td></tr></table></figure>
<p>我自己的蹩脚做法：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> job, if(<span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">%</span><span class="number">2</span><span class="operator">&gt;</span><span class="number">0</span>, (<span class="built_in">count</span>(<span class="operator">*</span>) div <span class="number">2</span>)<span class="operator">+</span><span class="number">1</span>,<span class="built_in">count</span>(<span class="operator">*</span>) div <span class="number">2</span>) <span class="keyword">start</span>,</span><br><span class="line">            if(<span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">%</span><span class="number">2</span><span class="operator">&gt;</span><span class="number">0</span>, (<span class="built_in">count</span>(<span class="operator">*</span>) div <span class="number">2</span>)<span class="operator">+</span><span class="number">1</span>,(<span class="built_in">count</span>(<span class="operator">*</span>) div <span class="number">2</span>)<span class="operator">+</span><span class="number">1</span>)<span class="keyword">end</span></span><br><span class="line"><span class="keyword">from</span> grade</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> job;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 可以优化一下</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> job, ((<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">+</span> <span class="number">1</span>) div <span class="number">2</span>) <span class="keyword">start</span>,</span><br><span class="line">            ((<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">+</span> <span class="number">2</span>) div <span class="number">2</span>) <span class="keyword">end</span></span><br><span class="line"><span class="keyword">from</span> grade</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> job</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> job;</span><br></pre></td></tr></table></figure>
<p>顺带复习了几种计算除法的函数。<br>求余：<code>select a % b</code>, <code>select a mod b</code><br>求模：<code>select a div b</code><br>求整：floor()函数向下取整，ceiling()向上取整</p>
<h1 id="考试分数-3-0"><a href="#考试分数-3-0" class="headerlink" title="考试分数 3.0"></a>考试分数 3.0</h1><h2 id="description-5"><a href="#description-5" class="headerlink" title="description"></a>description</h2><p><strong>grade表</strong>，简况如下：</p>
<table>
<thead>
<tr>
<th align="center">id</th>
<th align="center">job</th>
<th align="center">score</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">C++</td>
<td align="center">11001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">C++</td>
<td align="center">10000</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">C++</td>
<td align="center">9000</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">Java</td>
<td align="center">12000</td>
</tr>
</tbody></table>
<p>查询各个岗位分数的中位数位置上的所有grade信息，并且按id升序排序，结果如下:</p>
<p>|id|job|score|t_rank|<br>|2|C++|10000|2|<br>|4|Java|12000|2|<br>|5|Java|13000|1|<br>|7|B|11000|2|</p>
<h2 id="key-4"><a href="#key-4" class="headerlink" title="key"></a>key</h2><ul>
<li>按照岗位分组，得到分组内的排名</li>
<li>将排名表和中位数表按 job 连接，查询排名等于中位数位置的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> t1.id, t1.job, t1.score, t1.t_rank</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> id, job, score,</span><br><span class="line">    (<span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> job <span class="keyword">order</span> <span class="keyword">by</span> score <span class="keyword">desc</span>)) <span class="keyword">as</span> t_rank</span><br><span class="line">    <span class="keyword">from</span> grade)t1</span><br><span class="line"><span class="keyword">left</span> <span class="keyword">join</span> (</span><br><span class="line">    <span class="keyword">select</span> job,</span><br><span class="line">    <span class="built_in">floor</span>((<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">+</span> <span class="number">1</span>) <span class="operator">/</span> <span class="number">2</span>) <span class="keyword">start</span>,</span><br><span class="line">    <span class="built_in">floor</span>((<span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">+</span> <span class="number">2</span>) <span class="operator">/</span> <span class="number">2</span>) <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">from</span> grade</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> job</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> job)t2</span><br><span class="line"><span class="keyword">on</span> t1.job <span class="operator">=</span> t2.job</span><br><span class="line"><span class="keyword">where</span> t1.t_rank <span class="operator">=</span> t2.start <span class="keyword">or</span> t1.t_rank <span class="operator">=</span> t2.end</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="牛客的课程订单分析-1-0"><a href="#牛客的课程订单分析-1-0" class="headerlink" title="牛客的课程订单分析 1.0"></a>牛客的课程订单分析 1.0</h1><h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p><strong>order_info 订单信息表</strong>，简况如下：<br><img src="../images/2021-03-18-13-23-37.png"></p>
<p>查询在2025-10-15以后，同一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程的订单信息，并且按照order_info的id升序排序。如下：<br><img src="../images/2021-03-18-13-24-14.png"></p>
<h2 id="Key"><a href="#Key" class="headerlink" title="Key"></a>Key</h2><p><strong>重点</strong>，不能直接对筛选后的结果进行分组，count(id)&gt;=2 的筛选，这样只会得到每个分组内的第一条记录。也就是要真正明白聚合函数的意义，所以这里要用到窗口函数。</p>
<ul>
<li>对初步筛选后的记录，用窗口函数计算每一行的所在分组（同一个用户）的总订单数</li>
<li>再筛选出订单数&gt;=2的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> id, user_id, product_name, status, client_id, <span class="type">date</span></span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> <span class="operator">*</span>, <span class="built_in">count</span>(id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id) id_num</span><br><span class="line">    <span class="keyword">from</span> order_info</span><br><span class="line">    <span class="keyword">where</span> <span class="type">date</span><span class="operator">&gt;</span><span class="string">&#x27;2025-10-15&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span></span><br><span class="line">    <span class="keyword">and</span> product_name <span class="keyword">in</span> (<span class="string">&#x27;C++&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)) t1</span><br><span class="line"><span class="keyword">where</span> id_num <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> id;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="牛客的课程订单分析-2-0"><a href="#牛客的课程订单分析-2-0" class="headerlink" title="牛客的课程订单分析 2.0"></a>牛客的课程订单分析 2.0</h1><h2 id="description-6"><a href="#description-6" class="headerlink" title="description"></a>description</h2><p>基于 order_info 表，查询在2025-10-15以后，如果有一个用户下单2个以及2个以上状态为购买成功的C++课程或Java课程或Python课程，那么输出这个用户的user_id，以及满足前面条件的第一次购买成功的C++课程或Java课程或Python课程的日期first_buy_date，以及满足前面条件的第二次购买成功的C++课程或Java课程或Python课程的日期second_buy_date，以及购买成功的C++课程或Java课程或Python课程的次数cnt，并且输出结果按照user_id升序排序，结果如下：</p>
<table>
<thead>
<tr>
<th align="center">user_id</th>
<th align="center">first_buy_date</th>
<th align="center">second_buy_date</th>
<th align="center">cnt</th>
</tr>
</thead>
<tbody><tr>
<td align="center">57</td>
<td align="center">2025-10-23</td>
<td align="center">2025-10-24</td>
<td align="center">2</td>
</tr>
<tr>
<td align="center">557336</td>
<td align="center">2025-10-23</td>
<td align="center">2025-10-25</td>
<td align="center">3</td>
</tr>
</tbody></table>
<h2 id="Key-1"><a href="#Key-1" class="headerlink" title="Key"></a>Key</h2><ul>
<li>对初步筛选后的记录，用窗口函数计算每个按用户分组的区间按 date 排序的排序值，再用窗口函数计算每个按用户分组的区间的总订单数记为 cnt。得到t1</li>
<li>从 t1 中筛选出排序值 &lt;= 2 的且 cnt &gt; 2的记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"> t1.user_id,</span><br><span class="line"> <span class="built_in">min</span>(t1.date) <span class="keyword">as</span> first_buy_date,</span><br><span class="line"> <span class="built_in">max</span>(t1.date) <span class="keyword">as</span> second_buy_date,</span><br><span class="line"> t1.cnt</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">    (<span class="keyword">select</span> </span><br><span class="line">     user_id, <span class="type">date</span>,</span><br><span class="line">     <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>) d_rank, </span><br><span class="line">     <span class="built_in">count</span>(id) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id) cnt</span><br><span class="line">     <span class="keyword">from</span> order_info</span><br><span class="line">     <span class="keyword">where</span> <span class="type">date</span><span class="operator">&gt;</span><span class="string">&#x27;2025-10-15&#x27;</span></span><br><span class="line">       <span class="keyword">and</span> status <span class="operator">=</span> <span class="string">&#x27;completed&#x27;</span></span><br><span class="line">       <span class="keyword">and</span> product_name <span class="keyword">in</span> (<span class="string">&#x27;C++&#x27;</span>,<span class="string">&#x27;Java&#x27;</span>,<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">    ) t1</span><br><span class="line"><span class="keyword">where</span> t1.d_rank <span class="operator">&lt;=</span><span class="number">2</span> <span class="keyword">and</span> t1.cnt <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> t1.user_id, t1.cnt</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> t1.user_id;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用函数总结</title>
    <url>/2021-01-07-MySQL%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h1><p><em>注：<strong>hive</strong>、<strong>oracle</strong>提供窗口函数，<strong>mysql8之前版本</strong>不提供</em>，<em>但Oracle发布的 <strong>MySQL 8.0</strong>版本支持窗口函数（over）和公用表表达式（with）这两个重要的功能！</em></p>
<p>窗口函数是在满足某种条件的记录集合上执行的特殊函数，对于每条记录都要在此窗口内执行函数。函数可分为静态窗口函数和动态窗口函数。</p>
<ul>
<li>静态窗口函数：随着记录不同，窗口大小都是固定的</li>
<li>动态窗口函数：不同的记录对应着不同的窗口。</li>
</ul>
<p>窗口函数的本质还是聚合运算，只不过更具灵活性，它对数据的每一行，都使用与该行相关的行进行计算并返回计算结果。</p>
<p><strong>语法</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">窗口函数名([<span class="operator">&lt;</span>字段名<span class="operator">&gt;</span>]) <span class="keyword">over</span>([<span class="keyword">partition</span> <span class="keyword">by</span> <span class="operator">&lt;</span>分组字段<span class="operator">&gt;</span>] [<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>排序字段<span class="operator">&gt;</span> [<span class="keyword">desc</span>]] [<span class="operator">&lt;</span></span><br><span class="line">滑动窗口<span class="operator">&gt;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 比如“排序”</span></span><br><span class="line"><span class="built_in">row_number</span>(),<span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> <span class="type">date</span> <span class="keyword">order</span> <span class="keyword">by</span> id <span class="keyword">desc</span>)</span><br></pre></td></tr></table></figure>
<p>窗口函数的一个概念是当前行，当前行属于某个窗口，窗口由<strong>over关键字</strong>来指定函数执行的窗口范围，<br>如果后面括号中什么都不写，则意味着窗口包含满足where条件的所有行，窗口函数基于所有行进行计算；如果不为空，则有三个参数来设置窗口：</p>
<ul>
<li>partition by子句：按照指定字段进行分区，两个分区由边界分隔，窗口函数在不同的分区内分别执行，在跨越分区边界时重新初始化。</li>
<li>order by子句：按照指定字段进行排序，窗口函数将按照排序后的记录顺序进行编号。可以和<br>partition by子句配合使用，也可以单独使用。</li>
<li>frame子句：当前分区的一个子集，用来定义子集的规则，通常用来作为滑动窗口使用。</li>
</ul>
<p>对于滑动窗口的范围指定，通常使用 between frame_start and frame_end 语法来表示行范围，frame_start和frame_end可以支持如下关键字，来确定不同的动态行记录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">current row 边界是当前行，一般和其他范围关键字一起使用</span><br><span class="line">unbounded preceding 边界是分区中的第一行</span><br><span class="line">unbounded following 边界是分区中的最后一行</span><br><span class="line">expr preceding 边界是当前行减去expr的值</span><br><span class="line">expr following 边界是当前行加上expr的值</span><br></pre></td></tr></table></figure>
<p>比如，下面都是合法的范围：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="number">1</span> following 窗口范围是分区中的当前行、前一行、后一行一共三行记录。</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">1</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span> 窗口范围是分区中的前一行、当前行一共两行记录。</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> <span class="number">1</span> following 窗口范围是分区中的当前行、后一行一共两行记录。</span><br><span class="line"><span class="keyword">rows</span> unbounded preceding 窗口范围是分区中的第一行到当前行。</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span> 窗口范围是分区中的第一行到当前行。</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> unbounded following 窗口范围是分区中的当前行到最后一行。</span><br><span class="line"><span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> unbounded following 窗口范围是当前分区中所有行。</span><br></pre></td></tr></table></figure>
<h2 id="动态窗口函数"><a href="#动态窗口函数" class="headerlink" title="动态窗口函数"></a>动态窗口函数</h2><p>first_value() / last_value() / nth_value()/聚合函数用于窗口</p>
<ul>
<li>如没有指定排序和滑动窗口范围，默认计算的是分区内的所有记录。</li>
<li>指定分区和排序后，如没有指定滑动窗口范围，默认计算的是分区内的第一行到当前行。</li>
</ul>
<h3 id="FIRST-VALUE-和-LAST-VALUE函数"><a href="#FIRST-VALUE-和-LAST-VALUE函数" class="headerlink" title="FIRST_VALUE 和 LAST_VALUE函数"></a>FIRST_VALUE 和 LAST_VALUE函数</h3><p><code>FIRST_VALUE</code> 取分组内排序后，截止到当前行，第一个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT cookieid,createtime,pv,</span><br><span class="line">ROW_NUMBER() OVER(PARTITION BY cookieid ORDER BY createtime) AS rn,</span><br><span class="line">FIRST_VALUE(pv) OVER(PARTITION BY cookieid ORDER BY createtime) AS first  </span><br><span class="line">FROM test1;</span><br></pre></td></tr></table></figure>
<p><strong>LAST_VALUE 函数则相反：</strong><br><code>LAST_VALUE</code> 取分组内排序后，截止到当前行，最后一个值</p>
<hr>
<h2 id="静态窗口函数"><a href="#静态窗口函数" class="headerlink" title="静态窗口函数"></a>静态窗口函数</h2><p>row_number() / rank() / dense_rank() / percent_rank() / cume_dist()/lag() /<br>lead() / ntile()</p>
<ul>
<li>不管是否指定滑动窗口范围，窗口都是固定的，所以指定的滑动窗口范围无效。</li>
</ul>
<p>窗口函数和普通聚合函数的区别：</p>
<ul>
<li>聚合函数是将多条记录聚合为一条；而窗口函数是每条记录都会执行，有几条记录执行完还是几条。</li>
<li>聚合函数也可以用于窗口函数中。</li>
</ul>
<h3 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h3><ul>
<li>rank()：重复间断的组内排序，例如 1，1，3，4，4，6</li>
<li>dense_rank()：重复不间断的组内排序，例如 1，1，2，2，3</li>
<li>row_number()：不重复不间断的组内排序，例如 1，2，3，4，5</li>
</ul>
<h3 id="cume-dist"><a href="#cume-dist" class="headerlink" title="cume_dist()"></a>cume_dist()</h3><p><em>注：不允许在 CUME_DIST 函数中使用组合排序键（RANGE,ROWS）</em></p>
<p><code>cume_dist</code> 计算某个值在一组行中的相对位置</p>
<p>以下示例返回一个包含居住在 California 的职员的<strong>薪水累计分布的结果集</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DepartmentID, Surname, Salary,</span><br><span class="line"><span class="built_in">CUME_DIST</span>() <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> DepartmentID <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span>) &quot;Rank&quot; </span><br><span class="line"><span class="keyword">FROM</span> Employees  </span><br><span class="line"><span class="keyword">WHERE</span> State <span class="keyword">IN</span> (<span class="string">&#x27;CA&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>以下是该结果集：</p>
<table>
<thead>
<tr>
<th>DepartmentID</th>
<th>Surname</th>
<th>Salary</th>
<th>Rank</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>Savarino</td>
<td>72300.000</td>
<td>0.333333333333333</td>
</tr>
<tr>
<td>200</td>
<td>Clark</td>
<td>45000.000</td>
<td>0.666666666666667</td>
</tr>
<tr>
<td>200</td>
<td>Overbey</td>
<td>39300.000</td>
<td>1</td>
</tr>
</tbody></table>
<p>也就是说，薪水小于等于72300的人，占整个分组的0.33；薪水小于等于45000的人，占整个分组的0.66。</p>
<h3 id="PERCENT-RANK-函数"><a href="#PERCENT-RANK-函数" class="headerlink" title="PERCENT_RANK 函数"></a>PERCENT_RANK 函数</h3><p>与 PERCENT 函数类似，PERCENT_RANK 函数为窗口的 ORDER BY 子句所指定列中的值返回秩，但以介于 0 和 1 之间的小数形式表示，计算方法为 (分组内当前行的RANK值-1) / (分组内总行数-1)</p>
<p>随着窗口在输入行中向下移动，会计算在窗口的 ORDER BY 子句中所指定的表达式的秩。当 ORDER BY 子句包括多个表达式时，若第一个表达式与相邻行具有相同值，则第二个及后续表达式将用于区分并列情况。NULL 值排在任何其它值的前面（在升序序列中）。</p>
<p><strong>示例 1</strong></p>
<p>以下示例返回按性别显示 New York 雇员薪水排位的结果集。该结果使用百分比数按降序列出排位并按性别分区。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DepartmentID, Surname, Salary, Sex,    <span class="built_in">PERCENT_RANK</span>( ) <span class="keyword">OVER</span> ( <span class="keyword">PARTITION</span> <span class="keyword">BY</span> Sex      <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ) <span class="keyword">AS</span> PctRank  <span class="keyword">FROM</span> Employees   <span class="keyword">WHERE</span> State <span class="keyword">IN</span> ( <span class="string">&#x27;NY&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>此查询会返回以下结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>DepartmentID</th>
<th>Surname</th>
<th>Salary</th>
<th>Sex</th>
<th>PctRank</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>200</td>
<td>Martel</td>
<td>55700.000</td>
<td>M</td>
<td>0.0</td>
</tr>
<tr>
<td>2</td>
<td>100</td>
<td>Guevara</td>
<td>42998.000</td>
<td>M</td>
<td>0.333333333</td>
</tr>
<tr>
<td>3</td>
<td>100</td>
<td>Soo</td>
<td>39075.000</td>
<td>M</td>
<td>0.666666667</td>
</tr>
<tr>
<td>4</td>
<td>400</td>
<td>Ahmed</td>
<td>34992.000</td>
<td>M</td>
<td>1.0</td>
</tr>
<tr>
<td>5</td>
<td>300</td>
<td>Davidson</td>
<td>57090.000</td>
<td>F</td>
<td>0.0</td>
</tr>
<tr>
<td>6</td>
<td>400</td>
<td>Blaikie</td>
<td>54900.000</td>
<td>F</td>
<td>0.333333333</td>
</tr>
<tr>
<td>7</td>
<td>100</td>
<td>Whitney</td>
<td>45700.000</td>
<td>F</td>
<td>0.666666667</td>
</tr>
<tr>
<td>8</td>
<td>400</td>
<td>Wetherby</td>
<td>35745.000</td>
<td>F</td>
<td>1.0</td>
</tr>
</tbody></table>
<p>由于按性别 (Sex) 划分输入，所以分别对男雇员和女雇员执行 PERCENT_RANK 计算。</p>
<p><strong>示例 2</strong></p>
<p>以下示例返回 Utah 和 Arizona 的一些女雇员的列表并根据薪水以降序顺序排列她们。这里的 PERCENT_RANK 函数用于以降序顺序提供累计总数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Surname, Salary,      <span class="built_in">PERCENT_RANK</span> ( ) <span class="keyword">OVER</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ) &quot;Rank&quot;     <span class="keyword">FROM</span> Employees  <span class="keyword">WHERE</span> State <span class="keyword">IN</span> ( <span class="string">&#x27;UT&#x27;</span>, <span class="string">&#x27;AZ&#x27;</span> ) <span class="keyword">AND</span> Sex <span class="keyword">IN</span> ( <span class="string">&#x27;F&#x27;</span> );</span><br></pre></td></tr></table></figure>
<p>此查询会返回以下结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>Surname</th>
<th>Salary</th>
<th>Rank</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Shishov</td>
<td>72995.00</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>Jordan</td>
<td>51432.00</td>
<td>0.25</td>
</tr>
<tr>
<td>3</td>
<td>Hildebrand</td>
<td>45829.00</td>
<td>0.5</td>
</tr>
<tr>
<td>4</td>
<td>Bigelow</td>
<td>31200.00</td>
<td>0.75</td>
</tr>
<tr>
<td>5</td>
<td>Bertrand</td>
<td>29800.00</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>使用 PERCENT_RANK 查找最高和最低百分点</strong></p>
<p>在以下示例中，查询会返回其薪水在数据集的最高的五个百分点之内的男雇员。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>  </span><br><span class="line"><span class="keyword">FROM</span>  ( <span class="keyword">SELECT</span> Surname, Salary,</span><br><span class="line">       <span class="built_in">PERCENT_RANK</span> ( ) <span class="keyword">OVER</span> ( <span class="keyword">ORDER</span> <span class="keyword">BY</span> Salary <span class="keyword">DESC</span> ) &quot;Rank&quot;     </span><br><span class="line">       <span class="keyword">FROM</span> Employees  </span><br><span class="line">       <span class="keyword">WHERE</span> Sex <span class="keyword">IN</span> ( <span class="string">&#x27;M&#x27;</span> )  ) </span><br><span class="line">       <span class="keyword">AS</span> DerivedTable ( Surname, Salary, <span class="keyword">Percent</span> ) </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">Percent</span> <span class="operator">&lt;</span> <span class="number">0.05</span>;</span><br></pre></td></tr></table></figure>
<p>此查询会返回以下结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>Surname</th>
<th>Salary</th>
<th>Percent</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Scott</td>
<td>96300.00</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>Sheffield</td>
<td>87900.00</td>
<td>0.025</td>
</tr>
<tr>
<td>3</td>
<td>Lull</td>
<td>87900.00</td>
<td>0.025</td>
</tr>
</tbody></table>
<h3 id="前后函数"><a href="#前后函数" class="headerlink" title="前后函数"></a>前后函数</h3><p>​                   <strong>lag(expr,n)                / lead(expr,n)</strong><br>分区中位于当前行前n行（lag）/ 后n行(lead)的记录值<br>示例：查询各部门员工入职间隔天数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,datediff(hiredate,前一位员工的入职日期) <span class="keyword">as</span> 间隔天数</span><br><span class="line"><span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span>,<span class="built_in">lag</span>(hiredate,<span class="number">1</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> deptno <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> 前</span><br><span class="line">一位员工的入职日期 <span class="keyword">from</span> emp) <span class="keyword">as</span> t;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+-----------+------+------------+------+------+--------+----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> empno <span class="operator">|</span> ename <span class="operator">|</span> job    <span class="operator">|</span> mgr <span class="operator">|</span> hiredate  <span class="operator">|</span> sal <span class="operator">|</span> comm <span class="operator">|</span> deptno <span class="operator">|</span> 前一位员工的入职日期 <span class="operator">|</span> 间隔天数 <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------+--------+-----------+------+------------+------+------+--------+----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7782</span> <span class="operator">|</span> clark <span class="operator">|</span> manager  <span class="operator">|</span> <span class="number">7839</span> <span class="operator">|</span> <span class="number">1981</span><span class="number">-06</span><span class="number">-09</span> <span class="operator">|</span> <span class="number">2450</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span>    <span class="keyword">NULL</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7839</span> <span class="operator">|</span> king  <span class="operator">|</span> persident <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">1981</span><span class="number">-11</span><span class="number">-17</span> <span class="operator">|</span> <span class="number">5000</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> <span class="number">1981</span><span class="number">-06</span><span class="number">-09</span>   <span class="operator">|</span>    <span class="number">161</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">7934</span> <span class="operator">|</span> miller <span class="operator">|</span> clerk   <span class="operator">|</span> <span class="number">7782</span> <span class="operator">|</span> <span class="number">1982</span><span class="number">-01</span><span class="number">-23</span> <span class="operator">|</span> <span class="number">1300</span> <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">10</span> <span class="operator">|</span> <span class="number">1981</span><span class="number">-11</span><span class="number">-17</span>    <span class="operator">|</span>    <span class="number">67</span>   <span class="operator">|</span></span><br></pre></td></tr></table></figure>


<h3 id="NTILE-函数"><a href="#NTILE-函数" class="headerlink" title="NTILE 函数"></a>NTILE 函数</h3><p>NTILE(n), 用于将分组函数按照顺序切分成n片，返回当前切片值</p>
<p>例如：</p>
<p>统计一个cookie，pv数最多的前1/3的天：取 <code>ntile = 1</code> 的记录，就是我们想要的结果</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> pv <span class="keyword">DESC</span>) <span class="keyword">AS</span> ntile </span><br><span class="line"><span class="keyword">FROM</span> test1;</span><br></pre></td></tr></table></figure>
<p><em>注1：如果切片不均匀，<strong>默认增加第一个切片的分布</strong></em><br><em>注2：NTILE不支持ROWS BETWEEN</em></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cookieid,createtime,pv,</span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">2</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> ntile1,	<span class="comment">--分组内将数据分成2片</span></span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> ntile2,  <span class="comment">--分组内将数据分成3片</span></span><br><span class="line"><span class="built_in">NTILE</span>(<span class="number">4</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> cookieid <span class="keyword">ORDER</span> <span class="keyword">BY</span> createtime) <span class="keyword">AS</span> ntile3   <span class="comment">--将所有数据分成4片</span></span><br><span class="line"><span class="keyword">FROM</span> test1 </span><br><span class="line"><span class="comment">-- ...</span></span><br></pre></td></tr></table></figure>


























]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title>XGBoost</title>
    <url>/2021-01-12-XGBoost/</url>
    <content><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>XGBoost全称是 etreme gradient boosting，可译为极限梯度提升算法。它由陈天奇所设计，致力于让提升树突破自身的计算极限，以实现运算快速、性能优秀的工程目标。和传统的梯度提升算法相比，XGBoost进行了许多改进，它能够比其他使用梯度提升的集成算法更加快速，并且已经被认为是在分类和回归上都拥有超高性能的先进评估器。</p>
<h2 id="xgboost库"><a href="#xgboost库" class="headerlink" title="xgboost库"></a>xgboost库</h2><p>xgboost是一个独立的、开源的，专门提供梯度提升树以及XGBoost算法应用的算法库。和sklearn相似，有一个详细的官方网站可供查看，并且可以与 C，Python，R， Julia等语言连用，需要单独下载安装。</p>
<h1 id="二、基本思想"><a href="#二、基本思想" class="headerlink" title="二、基本思想"></a>二、基本思想</h1><p>XGBoost是Boosting算法中的一种。Boosting算法的思想是将许多弱分类器集成在一起形成一个强分类器。因为XGBoost是一种提升树模型，所以它是将许多树模型集成在一起。所用到的树模型是CART回归树模型。</p>
<h2 id="1-CART回归树"><a href="#1-CART回归树" class="headerlink" title="1. CART回归树"></a>1. CART回归树</h2><p>CART回归树是假设树为二叉树，不断将特征进行分裂。实质上就是在该特征维度对样本空间进行划分。</p>
<p>目标：遍历所有特征的所有切分点，找到最优的切分特征和切分点。最终得到一颗回归树。</p>
<h2 id="2-XGBoost算法思想"><a href="#2-XGBoost算法思想" class="headerlink" title="2. XGBoost算法思想"></a>2. XGBoost算法思想</h2><p>算法思想就是不断地不断进行特征分裂来添加树，每次添加一个树，其实是学习一个新函数，去拟合上次预测的残差。当我们训练完成得到k棵树，要预测一个样本的分数就根据这个样本的特征，在每棵树中会落到对应的一个叶子节点，每个叶子节点对应一个分数，最后只需要将每棵树对应的分数加起来就是该样本的预测值。</p>
<p><img src="../images/xgboost/1.png"></p>
<p><img src="../images/2021-03-08-14-12-10.png"><br>就这样，训练出了2棵树tree1和tree2，两棵树的结论累加起来便是最终的结论，所以小孩的预测分数就是两棵树中小孩所落到的结点的分数相加∶2+0.9=2.9。爷爷的预测分数同理:-1＋(-0.9) =-1.9。具体如下图所示:<br><img src="../images/2021-03-08-14-13-34.png"></p>
<h1 id="三、XGBoost基本原理"><a href="#三、XGBoost基本原理" class="headerlink" title="三、XGBoost基本原理"></a>三、XGBoost基本原理</h1><h2 id="1-目标函数"><a href="#1-目标函数" class="headerlink" title="1. 目标函数"></a>1. 目标函数</h2><p><img src="../images/xgboost/2.png"></p>
<ul>
<li>损失函数，可以是平方损失或逻辑损失</li>
<li>正则项，加入正则项的好处是防止过拟合。一是预剪枝，：T代表叶子节点数，γ可以控制叶子节点的个数。二是leaf score的L2模平方系数对leaf score做了平滑：ω代表叶子节点的分数(leaf score)，λ可以控制leaf score不会过大。</li>
</ul>
<p>所以，当生成t棵树后，总体目标就是一方面要最小化Loss 函数，一方面要让树模型更精简。<strong>由此衍生了一个结构分数</strong>，代表了当我们指定一个树的结构时，我们在目标上面最多减多少。类似Gini系数一样的对树结构打分的函数。</p>
<h2 id="2-寻找最佳分支：结构分数之差-Gain"><a href="#2-寻找最佳分支：结构分数之差-Gain" class="headerlink" title="2. 寻找最佳分支：结构分数之差(Gain)"></a>2. 寻找最佳分支：结构分数之差(Gain)</h2><p><img src="../images/xgboost/3.png"></p>
<p>所以在XGB的运行过程中，会根据结构分数寻找最佳的树。</p>
<p><img src="../images/xgboost/4.png"></p>
<h1 id="四、参数简要说明"><a href="#四、参数简要说明" class="headerlink" title="四、参数简要说明"></a>四、参数简要说明</h1><h2 id="1-有放回的随机抽样：参数subsample"><a href="#1-有放回的随机抽样：参数subsample" class="headerlink" title="1. 有放回的随机抽样：参数subsample"></a>1. 有放回的随机抽样：参数subsample</h2><p>在梯度提升树中，每构建一个评估器，都让模型更加集中于数据集中那些容易被判错的样本，加大它们的权重。持续反馈。。。</p>
<h2 id="2-迭代决策树：参数eta"><a href="#2-迭代决策树：参数eta" class="headerlink" title="2. 迭代决策树：参数eta"></a>2. 迭代决策树：参数eta</h2><p>因为模型会更加倾向于攻克那些难以判断的样本，那么，如何构造更好的树？——</p>
<p>除了保证模型逐渐倾向于困难样本的方向，还必须控制新弱分类器的生成，然后让新添加的树是对这个新数据集预测效果最优的那一棵树。</p>
<p>eta是迭代决策树时的步长，又叫做学习率。和逻辑回归里的类型，步长越大，迭代速度越快，很快达到算法极限，有可能无法收敛到真正的最佳，步长越小，越有可能找到更精确的最佳值，但速度会比较慢。</p>
<h2 id="3-选择弱分类器：参数booster"><a href="#3-选择弱分类器：参数booster" class="headerlink" title="3. 选择弱分类器：参数booster"></a>3. 选择弱分类器：参数booster</h2><p>booster可以选择使用什么样的弱评估器，树模型gbtree、线性模型gblinear，</p>
<p>每种评估器对应的params也不同，都有自己的params列表，评估器必须有param参数相匹配。</p>
<h2 id="4-XGB的目标函数：参数objective"><a href="#4-XGB的目标函数：参数objective" class="headerlink" title="4. XGB的目标函数：参数objective"></a>4. XGB的目标函数：参数objective</h2><p>选择不同的损失函数取决于要解决什么问题 ——</p>
<p>回归预测：均方误差RMSE</p>
<p>分类预测：错误率error 或者 对数损失 log_loss</p>
<p>只要选出的函数可微，能够代表某种损失的函数，就可以。</p>
<p>损失函数的核心是衡量模型的泛化能力，即模型在未知数据上的预测的准确与否。XGB是实现了模型表现和运算速度的平衡的算法，因此引入了模型复杂度来衡量算法的运算效率，所以XGB的目标函数被写作：传统损失函数 + 模型复杂度</p>
<p><img src="../images/xgboost/5.png"></p>
<h2 id="5-参数化决策树：参数lambda"><a href="#5-参数化决策树：参数lambda" class="headerlink" title="5. 参数化决策树：参数lambda"></a>5. 参数化决策树：参数lambda</h2><p>调节lambda越大，惩罚越重，正则项比例越大，可以让模型的复杂度变低，对于天生过拟合的XGB来说，可以一定程度上提升模型效果。可以使用网格搜索调整。</p>
<h2 id="6-让树停止生长：参数gamma"><a href="#6-让树停止生长：参数gamma" class="headerlink" title="6. 让树停止生长：参数gamma"></a>6. 让树停止生长：参数gamma</h2><p>gamma可以控制叶子节点的个数，也叫“复杂性控制”，是防止过拟合的重要参数。如何让树停止生长——</p>
<p>在XGB中，我们规定，只要结构分数之差Gain是大于0的，即只要目标函数还能够继续减小，我们就允许树继续进行分支，可以直接通过设定gamma的大小来让XGB中树停止生长，所以gamma也叫：在树的叶子节点上进行进一步分支所需的最小目标函数减少量。gamma越大，算法就越保守，树的叶子数量就越少，模型的复杂度就越低。</p>
<p><img src="../images/xgboost/6.png"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>集成算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>“数智教育”可视化分析</title>
    <url>/2021-01-05-%E2%80%9C%E6%95%B0%E6%99%BA%E6%95%99%E8%82%B2%E2%80%9D%E5%8F%AF%E8%A7%86%E5%8C%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="“数智教育”可视化分析"><a href="#“数智教育”可视化分析" class="headerlink" title="“数智教育”可视化分析"></a>“数智教育”可视化分析</h1><p><a href="https://public.tableau.com/profile/.58051095#!/vizhome/_luv5ic/5__">可视化报表地址</a></p>
<p>通过某学校教育数据的数据分析和可视化，探索面向学生、校园的数据分析体系，从而更好服务精细化教学管理工作。</p>
<h2 id="1、目的"><a href="#1、目的" class="headerlink" title="1、目的"></a>1、目的</h2><p>项目来源：<a href="https://tianchi.aliyun.com/competition/entrance/231704/introduction">天池–“数智教育”数据可视化创新大赛</a></p>
<ol>
<li><p>设计分析体系。</p>
</li>
<li><p>使用Navicat, MySQL对数据进行清洗，梳理纬度、新建指标值。</p>
</li>
<li><p>基于分析体系，利用Tableau建立仪表盘组成的动态可视化报表，能够使学校、年级、班级相关人员高效、准确地获取精细信息，从而实施管理或学习。</p>
</li>
</ol>
<p>待更新。。。</p>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>Tableau</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas常用函数总结</title>
    <url>/2021-03-11-Pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/">Pandas官方文档</a></p>
<h1 id="相关库"><a href="#相关库" class="headerlink" title="相关库"></a>相关库</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure>
<h1 id="Input-Output"><a href="#Input-Output" class="headerlink" title="Input/Output"></a>Input/Output</h1><h2 id="创建数据集"><a href="#创建数据集" class="headerlink" title="创建数据集"></a>创建数据集</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表和字典均可传入DataFrame，这里用的是字典传入：</span></span><br><span class="line">data=pd.DataFrame(&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:np.arange(<span class="number">101</span>,<span class="number">111</span>)                       </span><br><span class="line">   </span><br><span class="line">&#125;)</span><br><span class="line">data  </span><br></pre></td></tr></table></figure>
<h2 id="写入与读取"><a href="#写入与读取" class="headerlink" title="写入与读取"></a>写入与读取</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 写入</span></span><br><span class="line">data.to_csv(<span class="string">&quot;XXX.csv&quot;</span>,index=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;XXX.csv&#x27;</span>) <span class="comment">#单双引号都行</span></span><br></pre></td></tr></table></figure>
<p><a href="">Python中的单，双，三引号用法</a></p>
<h1 id="数据查看"><a href="#数据查看" class="headerlink" title="数据查看"></a>数据查看</h1><h2 id="数据集基础信息"><a href="#数据集基础信息" class="headerlink" title="数据集基础信息"></a>数据集基础信息</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.shape            <span class="comment"># 行数列数</span></span><br><span class="line">data.dtypes           <span class="comment"># 所有列的数据类型</span></span><br><span class="line">data[<span class="string">&#x27;id&#x27;</span>].dtype      <span class="comment"># 某一列的数据类型</span></span><br><span class="line">data.ndim             <span class="comment"># 数据维度</span></span><br><span class="line">data.index            <span class="comment"># 行索引</span></span><br><span class="line">data.columns          <span class="comment"># 列索引</span></span><br><span class="line">data.values           <span class="comment"># 对象值</span></span><br></pre></td></tr></table></figure>
<h2 id="数据集整体情况"><a href="#数据集整体情况" class="headerlink" title="数据集整体情况"></a>数据集整体情况</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.head()    <span class="comment"># 显示头部几行（默认5行）</span></span><br><span class="line">data.tail()    <span class="comment"># 显示末尾几行（默认5行）</span></span><br><span class="line">data.info()    <span class="comment"># 数据集相关信息概览：索引情况、列数据类型、非空值、内存使用情况</span></span><br><span class="line">data.describe()    <span class="comment"># 快速综合统计结果</span></span><br></pre></td></tr></table></figure>
<h1 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h1><h2 id="异常值"><a href="#异常值" class="headerlink" title="异常值"></a>异常值</h2><p>箱线图</p>
<h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><h3 id="空值查询"><a href="#空值查询" class="headerlink" title="空值查询"></a>空值查询</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.isnull()                <span class="comment"># 查看整个数据集的空值</span></span><br><span class="line">data[<span class="string">&#x27;columnA&#x27;</span>].isnull()  <span class="comment"># 查看某一列的空值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通常使用mean() 或 sum() 更好地查看空值所占频率和总数</span></span><br><span class="line">data.isnull().mean()</span><br><span class="line">data.isnull().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后汇总查看，更加直观</span></span><br><span class="line">data.isnull().<span class="built_in">sum</span>().sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h3 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h3><p><code>pandas.DataFrame.fillna（value = None，method = None，inplace = False）</code></p>
<ul>
<li>value：用于填充的值，可以是具体值、字典和数组，不能是列表；</li>
<li>method：填充方法，有 ffill(填充上一个值) 和 bfill(填充下一个值)  等；</li>
<li>inplace默认无False，如果为True，则将修改此对象上的所有其他视图。</li>
</ul>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.fillna.html">更多 pandas.DataFrame.fillna()用法</a></p>
</blockquote>
<h2 id="空格-‘-‘-‘-’-等特殊字符处理"><a href="#空格-‘-‘-‘-’-等特殊字符处理" class="headerlink" title="空格/‘-‘/‘_’ 等特殊字符处理"></a>空格/‘-‘/‘_’ 等特殊字符处理</h2><p>只针对object类型数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:                                  </span><br><span class="line">    <span class="keyword">if</span> pd.api.types.is_object_dtype(data[i]):     </span><br><span class="line">        data[i]=data[i].<span class="built_in">str</span>.strip()  </span><br></pre></td></tr></table></figure>
<h2 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series.<span class="built_in">str</span>.title()         <span class="comment"># 将首字母大写</span></span><br><span class="line">Series.<span class="built_in">str</span>.capitalize()    <span class="comment"># 将首字母大写</span></span><br><span class="line">Series.<span class="built_in">str</span>.upper()         <span class="comment"># 全部大写</span></span><br><span class="line">Series.<span class="built_in">str</span>.lower()         <span class="comment"># 全部小写</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.str.title.html">更多 pandas.Series.str 相关用法</a></p>
</blockquote>
<h2 id="数据替换"><a href="#数据替换" class="headerlink" title="数据替换"></a>数据替换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series.replace(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, inplace=<span class="literal">True</span>)              <span class="comment">#将A替换成B</span></span><br><span class="line"></span><br><span class="line">Series.replace(-<span class="number">10</span>,np.nan,inplace=<span class="literal">True</span>)             <span class="comment"># 将负值替换为空值</span></span><br><span class="line"></span><br><span class="line">Series.replace(np.nan,Series.mean(),inplace=<span class="literal">True</span>)   <span class="comment"># 将空值替换为均值</span></span><br></pre></td></tr></table></figure>
<h2 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h2><p><strong>等值判断</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data1 = data[data.origin != <span class="string">&#x27;American&#x27;</span>] <span class="comment">#去掉origin为American的行</span></span><br><span class="line"></span><br><span class="line">data2=data[(data != <span class="string">&#x27;Japan&#x27;</span>).<span class="built_in">all</span>(<span class="number">1</span>)]    <span class="comment">#去掉所有包含Japan的行。返回True值，即不等于Japan的行</span></span><br></pre></td></tr></table></figure>
<p><strong>去除重复值</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Series.drop_duplicates()      <span class="comment"># 默认删除后面出现的重复值，即保留第一次出现的重复值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates">更多 pandas.DataFrame.drop_duplicates() 用法</a></p>
</blockquote>
<h2 id="数据格式转换"><a href="#数据格式转换" class="headerlink" title="数据格式转换"></a>数据格式转换</h2><p>将某一列转换为 str 格式<br><code>Series.astype(&#39;str)</code></p>
<p>常见的数据类型对照<br><img src="../images/2021-03-12-00-01-44.png"></p>
<blockquote>
<p><a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.map.html">pandas.Series.map</a><br><a href="https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply">pandas.DataFrame.apply</a></p>
</blockquote>
<h2 id="更改column-name"><a href="#更改column-name" class="headerlink" title="更改column_name"></a>更改column_name</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.rename(columns=&#123;<span class="string">&#x27;id&#x27;</span>:<span class="string">&#x27;ID&#x27;</span>, <span class="string">&#x27;origin&#x27;</span>:<span class="string">&#x27;产地&#x27;</span>&#125;)     <span class="comment"># 将id列改为ID，将origin改为产地。</span></span><br></pre></td></tr></table></figure>
<h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="数据合并"><a href="#数据合并" class="headerlink" title="数据合并"></a>数据合并</h2><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p><code>DataFrame.merge(self，right，how =‘inner’，on = None)</code></p>
<ul>
<li>right 指要合并的对象</li>
<li>on 指要加入的列或索引级别名称，必须在两个 DataFrame 中都可以找到。</li>
<li>how 决定要执行的合并类型：left（使用左框架中的键）、right、inner（交集，默认）、outer（并集）</li>
</ul>
<p><strong>先创建两个df</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>], <span class="string">&#x27;b&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2 = pd.DataFrame(&#123;<span class="string">&#x27;a&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;baz&#x27;</span>], <span class="string">&#x27;c&#x27;</span>: [<span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1</span><br><span class="line">    a  b</span><br><span class="line"><span class="number">0</span>   foo  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   bar  <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">    a  c</span><br><span class="line"><span class="number">0</span>   foo  <span class="number">3</span></span><br><span class="line"><span class="number">1</span>   baz  <span class="number">4</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1.merge(df2, how=<span class="string">&#x27;inner&#x27;</span>, on=<span class="string">&#x27;a&#x27;</span>)       </span><br><span class="line">      a  b  c</span><br><span class="line"><span class="number">0</span>   foo  <span class="number">1</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1.merge(df2, how=<span class="string">&#x27;left&#x27;</span>, on=<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">      a  b  c</span><br><span class="line"><span class="number">0</span>   foo  <span class="number">1</span>  <span class="number">3.0</span></span><br><span class="line"><span class="number">1</span>   bar  <span class="number">2</span>  NaN</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1 = pd.DataFrame(&#123;<span class="string">&#x27;left&#x27;</span>: [<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2 = pd.DataFrame(&#123;<span class="string">&#x27;right&#x27;</span>: [<span class="number">7</span>, <span class="number">8</span>]&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1</span><br><span class="line">    left</span><br><span class="line"><span class="number">0</span>   foo</span><br><span class="line"><span class="number">1</span>   bar</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>df2</span><br><span class="line">    right</span><br><span class="line"><span class="number">0</span>   <span class="number">7</span></span><br><span class="line"><span class="number">1</span>   <span class="number">8</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>df1.merge(df2, how=<span class="string">&#x27;cross&#x27;</span>)</span><br><span class="line">   left  right</span><br><span class="line"><span class="number">0</span>   foo      <span class="number">7</span></span><br><span class="line"><span class="number">1</span>   foo      <span class="number">8</span></span><br><span class="line"><span class="number">2</span>   bar      <span class="number">7</span></span><br><span class="line"><span class="number">3</span>   bar      <span class="number">8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.merge.html">更多 pandas.DataFrame.merge() 用法</a></p>
</blockquote>
<h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p><strong>在原数据集的下方合并入新的数据集</strong><br><code>df1.append(df2)</code></p>
<h3 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h3><p><code>pandas.concat(objs,axis = 0,ignore_index = False,keys = None)</code></p>
<ul>
<li>objs:Series，DataFrame或Panel对象的序列或映射。</li>
<li>axis：串联的轴，默认为0，即以索引串联（竖直拼接）；如果为1，则以列串联（水平拼接）</li>
<li>ignore_index：清除现有索引并将其重置，默认为False。</li>
<li>key：在数据的最外层添加层次结构索引。</li>
</ul>
<p>比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data_new=pd.concat([data,data2,data3],axis = <span class="number">1</span>,keys=[<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;data2&#x27;</span>,<span class="string">&#x27;data3&#x27;</span>])</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/version/0.23.4/generated/pandas.concat.html">更多 pandas.concat() 用法</a></p>
</blockquote>
<h2 id="设置索引列"><a href="#设置索引列" class="headerlink" title="设置索引列"></a>设置索引列</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.set_index(<span class="string">&quot;id&quot;</span>)           <span class="comment"># 设置id为索引列</span></span><br><span class="line"></span><br><span class="line">data.reset_index(drop=<span class="literal">True</span>)    <span class="comment"># 重置索引列，并且避免将旧索引添加为列</span></span><br></pre></td></tr></table></figure>
<h2 id="按照特定列的值排序"><a href="#按照特定列的值排序" class="headerlink" title="按照特定列的值排序"></a>按照特定列的值排序</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.sort_index()              <span class="comment"># 设置id为索引列</span></span><br><span class="line"></span><br><span class="line">data.sort_values(by=<span class="string">&quot;columnA&quot;</span>,ascending = <span class="literal">True</span>)    <span class="comment"># 按照columnA的值排序，默认升序</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.sort_values.html">更多 pandas.DataFrame.sort_values()用法</a></p>
</blockquote>
<h2 id="分类显示"><a href="#分类显示" class="headerlink" title="分类显示"></a>分类显示</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果money列的值&gt;=10, level列显示high，否则显示low</span></span><br><span class="line">data[<span class="string">&#x27;level&#x27;</span>] = np.where(data[<span class="string">&#x27;money&#x27;</span>]&gt;=<span class="number">10</span>, <span class="string">&#x27;high&#x27;</span>, <span class="string">&#x27;low&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="分组标记"><a href="#分组标记" class="headerlink" title="分组标记"></a>分组标记</h2><p>定位到 level 行==high 并且 origin 行==China，sign列的数据。赋值为“棒”<br><code>data.loc[(data[&#39;level&#39;]==&quot;high&quot;) &amp; (data[&#39;origin&#39;]==&quot;China&quot;),&quot;sign&quot;]=&quot;棒&quot;</code></p>
]]></content>
  </entry>
  <entry>
    <title>Python中的单，双，三引号用法</title>
    <url>/2021-02-11-Python%E4%B8%AD%E7%9A%84%E5%8D%95%EF%BC%8C%E5%8F%8C%EF%BC%8C%E4%B8%89%E5%BC%95%E5%8F%B7%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="单引号和双引号"><a href="#单引号和双引号" class="headerlink" title="单引号和双引号"></a>单引号和双引号</h1><p>在Python中单引号和双引号都可以用来表示一个字符串，比如</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;python&#x27;</span></span><br><span class="line">str2 = <span class="string">&quot;python&quot;</span> </span><br><span class="line"><span class="comment"># str1和str2没有任何区别。</span></span><br></pre></td></tr></table></figure>
<h1 id="字符串中含有单引号"><a href="#字符串中含有单引号" class="headerlink" title="字符串中含有单引号"></a>字符串中含有单引号</h1><p>例如：I’m a big fan of Python.</p>
<p><strong>1、单引号版本：</strong><br><code>str3 = &#39;I\&#39;m a big fan of Python.&#39;</code><br>字符串中间的’必须用转移字符\才可以。如果数量多写法就不优雅，可以使用双引号。</p>
<p><strong>2、双引号版本：</strong><br><code>str4_ = &quot;We all know that &#39;A&#39; and &#39;B&#39; are two capital letters.&quot;</code></p>
<h1 id="字符串中有双引号"><a href="#字符串中有双引号" class="headerlink" title="字符串中有双引号"></a>字符串中有双引号</h1><p>为了避免使用转义符，使用单引号来定义这个字符串。<br>比如：<br><code>str5 = &#39;The teacher said: &quot;Practice makes perfect&quot; is a very famous proverb.&#39;</code></p>
<h1 id="3个单引号"><a href="#3个单引号" class="headerlink" title="3个单引号"></a>3个单引号</h1><p><strong>1、换行输出</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>str1 = <span class="string">&quot;&quot;&quot;List of name:</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Hua Li</span></span><br><span class="line"><span class="string"><span class="meta">... </span>Chao Deng</span></span><br><span class="line"><span class="string"><span class="meta">... </span>&quot;&quot;&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(str1)</span><br><span class="line">List of name:</span><br><span class="line">Hua Li</span><br><span class="line">Chao Deng</span><br></pre></td></tr></table></figure>
<p><strong>2、多段文字注释</strong></p>
]]></content>
      <tags>
        <tag>Elegant_python</tag>
      </tags>
  </entry>
  <entry>
    <title>爬虫入门</title>
    <url>/2021-01-19-%E7%88%AC%E8%99%AB%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>了解一点爬虫</p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>每⼀个我们能够访问的⽹站实际上都是被部署在⼀个带有⽹络连接的服务器中。每⼀个在线的服务器都会有⼀个IP地址，⽽我们将⽹站的域名绑定到这个IP地址上⾯，这样⼀来当我们访问这个域名的时候，实际上就和这个服务器建⽴起了连接。</p>
<p>首先明白<strong>网络连接</strong>：计算机带着请求头和消息体向服务器发起一次request，相应的服务器会返回本计算机所相应的HTML文件作为response。</p>
<p>即：计算机⼀次Request请求和服务器端的Response响应。所以对于爬虫来说需要：</p>
<p>(1) 模拟计算机对服务器发起Request请求<br>(2) 接收服务端的Response内容并解析, 提取所需的消息</p>
<p><strong>多页面</strong></p>
<p>多个⻚⾯的⽹⻚结构相同或相似, 这种类型的⽹⻚爬⾍流程为:<br>(1) ⼿动翻⻚并观察各⽹⻚的URL构成特点, 构造出所有⻚⾯的URL存⼊列表中.<br>(2) 根据URL列表依次循环取出URL<br>(3) 定义爬⾍函数<br>(4) 循环调⽤爬⾍函数, 储存数据.<br>(5) 循环完毕, 结束爬⾍程序</p>
<p><strong>跨页面（页面的URL可能没有具体的规则）</strong></p>
<ol>
<li>定义爬取函数爬取列表⻚的所有专题的URL</li>
<li>将专题URL存⼊列表中(种⼦URL)</li>
<li>定义爬取详细⻚数据函数</li>
<li>进⼊专题详细⻚⾯爬取详细⻚数据</li>
<li>储存数据, 循环完毕, 结束爬取程序</li>
</ol>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ul>
<li>应⽤于搜索引擎中对站点进⾏爬取收录</li>
<li>应⽤于数据分析与挖掘中对数据进⾏采集</li>
<li>应⽤于⾦融分析中对⾦融数据进⾏采集</li>
<li>应⽤于舆情监测与分析、⽬标客户数据的收集等各个领域</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>通用爬虫</li>
</ul>
<p>通⽤⽹络爬⾍ 是 捜索引擎抓取系统（Baidu、Google、Yahoo等）的重要组成部 分。主要⽬的是将互联⽹上的⽹⻚下载到本地，形成⼀个互联⽹内容的镜像备份。通⽤⽹络爬⾍ 从互联⽹中搜集⽹⻚，采集信息，这些⽹⻚信息⽤于为搜索引擎 建⽴索引从⽽提供⽀持，它决定着整个引擎系统的内容是否丰富，信息是否即时，因此其性能的优劣直接影响着搜索引擎的效果。</p>
<ul>
<li>聚焦爬虫</li>
</ul>
<p>聚焦爬⾍，是”⾯向特定主题需求”的⼀种⽹络爬⾍程序，它与通⽤搜索引擎爬⾍的区别在于： 聚焦爬⾍在实施⽹⻚抓取时会对内容进⾏处理筛选，尽量保证只抓取与需求相关的⽹⻚信息。<br>下面讲的是聚焦爬虫。</p>
<h2 id="爬虫的知识体系"><a href="#爬虫的知识体系" class="headerlink" title="爬虫的知识体系"></a>爬虫的知识体系</h2><ol>
<li>Python的基本语法</li>
<li>⽹站开发相关知识：HTTP协议，HTML</li>
<li>模拟请求库：requests</li>
<li>⽹⻚内容解析：re(正则表达式)，beautifulsoup，xpath解析返回的HTML响应⻚⾯</li>
<li>通过API接⼝获取数据</li>
<li>动态加载⽹⻚采集：Selenium⾃动化测试驱动</li>
<li>代理的使⽤</li>
<li>验证码识别</li>
<li>数据的储存：数据库的连接与使⽤</li>
<li>爬取APP数据<br>11 多线程爬⾍开发</li>
<li>Scrapy爬⾍框架的使⽤</li>
<li>分布式爬⾍</li>
</ol>
<h1 id="利用requests库访问网站"><a href="#利用requests库访问网站" class="headerlink" title="利用requests库访问网站"></a>利用requests库访问网站</h1><p>在此之前，要先了解网页的构成。</p>
<p>网页大致分为 HTML、CSS、JavaScript 三部分。</p>
<ol>
<li>HTML, 是⽹⻚的基础架构, 它⽤各种标签来表示内容,通过标签之间的各种嵌套组合, 组成了我们看到的⽹⻚.在HTML中，把这些标签叫做节点，所有节点构成一个树形的结构，叫做节点数。上级的 parent 节点，下级的 child 节点，同级的 sibling 节点等。</li>
<li>CSS，全称Cascading StyleSheets，即层叠样式表。“层叠”是指当在 HTML 中引⽤了数个样式⽂件，并且样式发⽣冲突时，浏览器能依据层叠顺序处理。 “样式”指⽹⻚中⽂字⼤⼩ 、 颜⾊ 、元素间距、排列等格式。css 是⽬前唯⼀的⽹⻚⻚⾯排版样式标<br>准。</li>
<li>JavaScript，简称 JS，是⼀种脚本语⾔ HTML 和 css 配合使⽤， 提供给⽤户的只是⼀种静态信息，缺乏交互性。我们在⽹⻚⾥可能会看到⼀些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是 JavaScript 的功劳。</li>
</ol>
<hr>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># headers是为了模仿使用真实的浏览器访问(伪装客户端)，否则有些网站会识别出是爬虫</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;user-agent&#x27;</span>:<span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.5 Safari/605.1.15&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># httpbin.org是一个开源的专门用于爬虫测试的网站, 通过这个网站可以获得很多, 爬虫正常访问网站的时候, 无法获取到的信息.</span></span><br><span class="line">url = <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GET 方法，发起get请求，返回页面信息</span></span><br><span class="line">r = requests.get(url, headers = headers)</span><br><span class="line">r</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将解析网站的语言换成网站编写的语言，预测的不一定都一定准确</span></span><br><span class="line">r.encoding = r.apparent_encoding </span><br><span class="line"></span><br><span class="line"><span class="comment"># 和请求的网页相关的所有内容,都封装在了r中</span></span><br><span class="line">r.url</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问的消息头</span></span><br><span class="line">r.headers</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取状态码</span></span><br><span class="line">r.status_code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网页源代码，打印不会改变源码格式</span></span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>服务端返回给客户端, 分为三部分:</p>
<p>响应状态码(Response Status Code) ,<br>响应头(Respongse Headers),<br>和响应体(Respongse body ).<br>响应状态码<br>响应状态码表示服务器的响应状态, 是否正常, 能够找到网页等等.</p>
<p>最常见的:</p>
<p>200代表正常,</p>
<p>301/302网页重定向(迁移)</p>
<p>404代表没找到页面,</p>
<p>403 Forbidden：请求资源的访问被服务器拒绝, 例如IP被封了</p>
<p>500服务器错误(例如服务器宕机了)</p>
<h2 id="GET方法传递url参数"><a href="#GET方法传递url参数" class="headerlink" title="GET方法传递url参数"></a>GET方法传递url参数</h2><p>一般来说, 我们访问的网页链接分为两种, 一种是动态网址, 一种是静态网址</p>
<p>网址中含有问号的符号就是动态网址, 例如: <a href="https://movie.douban.com/subject/19971676/comments?start=0&amp;limit=20&amp;sort=new_score&amp;status=P&amp;percent_type=h">https://movie.douban.com/subject/19971676/comments?start=0&amp;limit=20&amp;sort=new_score&amp;status=P&amp;percent_type=h</a></p>
<p>问号后面的是该网址的”参数”,参数是由 key=value的形式进行构造的, 多个参数之间由&amp;符号进行连接.</p>
<p>不同的参数控制了网页中的内容或者属性有所不同.</p>
<p>网址中没有问号的就是静态网址, 例如:</p>
<p><a href="http://top.chinaz.com/Html/site_weibo.com.html">http://top.chinaz.com/Html/site_weibo.com.html</a></p>
<p>这种网址不管如何访问, 进入的都是固定的页面.</p>
<h3 id="用字符串的方法手动构造"><a href="#用字符串的方法手动构造" class="headerlink" title="用字符串的方法手动构造"></a>用字符串的方法手动构造</h3><p>不管是动态网址还是静态网址, 我们都可以通过字符串的格式化等方法进行手动构造:</p>
<p>format方法:</p>
<ol>
<li>查询关键字<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;疫情&#x27;</span></span><br><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(word)</span><br><span class="line">print(url)</span><br><span class="line">r = requests.get(url,headers = headers)</span><br></pre></td></tr></table></figure></li>
<li>百度贴吧网址页数变化<br>使用循环<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    url = <span class="string">&quot;http://tieba.baidu.com/p/6487024722?pn=&#123;&#125;&quot;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    print(url)</span><br></pre></td></tr></table></figure>
<h3 id="使用requests库带的方法进行动态网址构造"><a href="#使用requests库带的方法进行动态网址构造" class="headerlink" title="使用requests库带的方法进行动态网址构造"></a>使用requests库带的方法进行动态网址构造</h3>requests库中也带有构造动态网址的方法, 使用的是params参数, 使用字典的数据类型传入参数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;https://www.baidu.com/s&#x27;</span> <span class="comment"># 静态部分</span></span><br><span class="line">word = <span class="string">&#x27;实时疫情&#x27;</span></span><br><span class="line">d = &#123;<span class="string">&#x27;ie&#x27;</span>:<span class="string">&quot;utf-8&quot;</span>,<span class="string">&quot;f&quot;</span>:<span class="string">&quot;8&quot;</span>,<span class="string">&quot;rsv_bp&quot;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&#x27;rsv_idx&#x27;</span>:<span class="string">&quot;1&quot;</span>,<span class="string">&quot;tn&quot;</span>:<span class="string">&quot;baidu&quot;</span>,<span class="string">&quot;wd&quot;</span>:word&#125;</span><br><span class="line">r =requests.get(url, params= d , headers= headers)</span><br><span class="line">r</span><br></pre></td></tr></table></figure>
<h2 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h2>POST请求大多数在表单提交时发起, 例如我们在登陆一个网站的时候, 需要输入用户名和密码</li>
</ol>
<p>用户名和密码不可能作为参数放到网址中去, 因此需要换一个传输方法.</p>
<p>我们把需要传输的内容, 作为表单传送过去, 而不是作为URL中的参数.</p>
<p>在Preview中可以查看, 向服务器发送的表单信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://httpbin.org/post&#x27;</span></span><br><span class="line">d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;haoxueai&#x27;</span>,<span class="string">&#x27;password&#x27;</span>:<span class="string">&#x27;1234567890&#x27;</span>,<span class="string">&#x27;captcha&#x27;</span>:<span class="string">&#x27;eszr&#x27;</span>&#125;</span><br><span class="line">r = requests.post(url,data = d, headers = headers)</span><br></pre></td></tr></table></figure>
<h1 id="Beautiful-Soup"><a href="#Beautiful-Soup" class="headerlink" title="Beautiful Soup"></a>Beautiful Soup</h1><p>Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库。它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式。Beautiful Soup会帮你节省数小时甚至数天的工作时间。</p>
<p>Beautiful Soup是一个利用HTML或者XML来对内容进行解析的解析库。</p>
<p>HTML的属性都具有结构上的层级关系, 而且有css和id属性, Beautiful Soup就是利用这样的关系进行提取</p>
<p><strong>Beautiful Soup的安装</strong><br><code>pip install bs4</code></p>
<p><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html">中文文档</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 尝试运行一个简单的Beautiful Soup例子</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://www.shuquge.com/txt/8659/index.html&quot;</span></span><br><span class="line">headers =&#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(url,headers=headers)</span><br><span class="line">r.encoding = r.apparent_encoding</span><br><span class="line"> </span><br><span class="line"><span class="built_in">type</span>(r.text)  <span class="comment"># str</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们为了在这个字符串中高效的搜索出我们需要的内容</span></span><br><span class="line"><span class="comment"># 利用BeautifulSoup 将这个字符串改变成BeautifulSoup类型</span></span><br><span class="line">bs = BeautifulSoup(r.text,<span class="string">&quot;lxml&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="搜索接口find-all"><a href="#搜索接口find-all" class="headerlink" title="搜索接口find_all"></a>搜索接口find_all</h2><ol>
<li>find_all 两个一样: 搜索出网页中所有符合你的参数要求的内容,返回的数据类型是列表,即使只有一个符合要求的,也会将这唯一的一个放入到列表中,如果需要还需要从列表中提取,比较麻烦.</li>
<li>find : 搜索出网页中第一个符合你的参数要求的内容, 一般来说,当你已知只有一个符合参数要求的内容的时候,就直接用find就可以了.</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">bs.find_all(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line">bs.find_all(<span class="string">&#x27;title&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># find 这个接口就是搜索出第一个符合要求的结果</span></span><br><span class="line">bs.find(<span class="string">&#x27;title&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索出所有的a标签内容 </span></span><br><span class="line">bs.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更加精确的定位方法, 配合标签的属性进行定位</span></span><br><span class="line"><span class="comment"># 属性名称 = 属性的值</span></span><br><span class="line"><span class="comment"># 在python中, class是一个关键字, 所有class后面需要加一个_,以便和关键字进行区分</span></span><br><span class="line">bs.find_all(<span class="string">&#x27;a&#x27;</span>, class_ = <span class="string">&#x27;brother&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为我们用的最多的是class, 所以当你搜索的是class的时候, 这个参数可以省略</span></span><br><span class="line">bs.find_all(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;littleboy&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过标签内的文本进行定位</span></span><br><span class="line">bs.find_all(<span class="string">&#x27;a&#x27;</span>,text = <span class="string">&#x27;罗恩&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过limit 参数限制返回的条数</span></span><br><span class="line">bs.find_all(<span class="string">&#x27;a&#x27;</span>,limit = <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">a = bs.find_all(<span class="string">&#x27;a&#x27;</span>,<span class="built_in">id</span>=<span class="string">&#x27;link1&#x27;</span>)[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>随机森林</title>
    <url>/2021-01-15-%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97/</url>
    <content><![CDATA[<p> bagging方法的代表算法是随机森林，准确的来说，随机森林是bagging的⼀个特化进阶版，所谓的特化是因为随机森林的弱学习器都是决策树。所谓的进阶是随机森林在bagging的样本随机采样基础上，⼜加上了特征的随机选择，其基本思想没有脱离bagging的范畴。分类树组成的森林就叫做随机森林分类器，回归树所集成的森林就叫做随机森林回归器。</p>
<p>什么是集成算法和bagging？——</p>
<p><strong>集成算法</strong></p>
<p>对于训练集数据，我们通过训练若⼲个弱评估器，通过⼀定的结合策略，就可以最终形成⼀个强评估器，这个强分类器的效果就是汇总之前多个模型的结果，来获取最优的表现结果。</p>
<p>它可以⽤来做市场营销模拟的建模，统计客户来源，保留和流失，也可⽤来预测疾病的⻛险和病患者的易感性。</p>
<p><strong>Bagging</strong></p>
<p><strong>原理</strong>：每次均匀地、有放回地随机选取与原数据集样本量相等的样本，得到若干个新数据集。再用若干个若评估器分别训练这些数据集，最终对每个评估器预测的结果根据平均或多数表决原则选取最优的预测结果。</p>
<p><img src="../images/rf/2.png"></p>
<h1 id="一、随机森林分类器"><a href="#一、随机森林分类器" class="headerlink" title="一、随机森林分类器"></a>一、随机森林分类器</h1><p>通过构造多个决策树，做bagging以提高泛化能力 </p>
<p>有哪些随机方法</p>
<h2 id="1-重要参数"><a href="#1-重要参数" class="headerlink" title="1. 重要参数"></a>1. 重要参数</h2><h3 id="1-1-控制基评估器的参数"><a href="#1-1-控制基评估器的参数" class="headerlink" title="1.1 控制基评估器的参数"></a>1.1 控制基评估器的参数</h3><table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>criterion</td>
<td><strong>不纯度的衡量指标</strong>，有基尼系数和信息熵两种选择</td>
</tr>
<tr>
<td>max_depth</td>
<td>树的最大深度，超过最⼤深度的树枝都会被剪掉</td>
</tr>
<tr>
<td>min_samples_leaf</td>
<td>⼀个节点<strong>在分枝后的每个⼦节点</strong>都必须包含⾄少min_samples_leaf个训练样本，否则分枝就不会发⽣</td>
</tr>
<tr>
<td>min_samples_split</td>
<td><strong>⼀个节点必须要包含</strong>⾄少min_samples_split个训练样本，这个节点才允许被分枝，否则分枝就不会发⽣</td>
</tr>
<tr>
<td>max_features</td>
<td>max_features限制分枝时考虑的特征个数，超过限制个数的特征都会被舍弃，<strong>默认值为总特征个数开平⽅取整</strong></td>
</tr>
<tr>
<td>min_impurity_decrease</td>
<td>限制信息增益的⼤⼩，信息增益⼩于设定数值的分枝不会发⽣</td>
</tr>
</tbody></table>
<h3 id="1-2-n-estimators"><a href="#1-2-n-estimators" class="headerlink" title="1.2 n_estimators"></a>1.2 n_estimators</h3><p>森林中树⽊的数量，即基评估器的数量。这个参数对随机森林模型的精确性影响是单调的，n_estimators越⼤，模型的效果往往越好。但是达到⼀定的程度之后，随机森林的精确性往往不再上升或开始波动，并且，n_estimators越⼤，需要的计算量和内存也越⼤，训练的时间也会越来越⻓。对于这个参数，目标是尽量在训练难度和模型效果之间取得平衡。</p>
<h3 id="1-3-random-state"><a href="#1-3-random-state" class="headerlink" title="1.3 random_state"></a>1.3 random_state</h3><p>sklearn中的分类树DecisionTreeClassifier自带随机性，所以随机森林中的树天⽣就都是不⼀样的。分类树中的参数数random_state是 从最重要的特征中随机选择出⼀个特征来进⾏分枝，因此每次⽣成的决策树都不⼀样。随机森林⽤法和分类树中相似，只不过在分类树中，⼀个random_state只<br>控制⽣成⼀棵树，⽽随机森林中的random_state控制的是⽣成森林的模式，⽽⾮让⼀个森林中有⼀<br>棵树。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#随机森林中的random_state控制的是⽣成森林的模式</span></span><br><span class="line">rfc = RandomForestClassifier(n_estimators=<span class="number">20</span>,random_state=<span class="number">2</span>)</span><br><span class="line">rfc = rfc.fit(Xtrain, Ytrain)</span><br><span class="line"><span class="comment">#随机森林的重要属性之⼀：estimators，查看森林中树的状况</span></span><br><span class="line">rfc.estimators_[<span class="number">0</span>].random_state</span><br><span class="line"><span class="comment">#打印出森林中所有树的随机模式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(rfc.estimators_)):</span><br><span class="line">    print(rfc.estimators_[i].random_state)</span><br></pre></td></tr></table></figure>
<p>当我们需要成千上万棵树的时候，数据不⼀定能够提供成千上万的特征来让我们构筑尽量多尽量不同的树。因此，除了random_state。我们还需要其他的随机性，比如max_features。</p>
<h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>给每一个训练样本赋予一个等量的初始权重，在每一轮训练结束时自动地调整权重。</p>
<p><img src="../images/rf/1.png"></p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>集成算法</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>记录第一次群面-神策-数据分析师</title>
    <url>/2021-03-31-%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%BE%A4%E9%9D%A2-%E7%A5%9E%E7%AD%96-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%B8%88/</url>
    <content><![CDATA[<p>记录第一次群面</p>
<p>2020-03-30</p>
<p>第一次接触群面。提前有搜到一些情报有：无领导、小组讨论、选一个组长和记录员、选一个汇报员给面试官汇报讨论内容。</p>
<p><strong>本次记录的内容：群面概况、两次讨论主题（小红书&amp;指标设计）、补充思考、反思与收获。</strong></p>
<p>我们小组是4个人，都是女生，除了我都是研究生，有两个分别是大连理工、北京理工的应用统计学研究生。没太听清她们是研几，希望我的自我介绍让面试官听清了【捂脸】。</p>
<p>自我介绍，面试官一开始让自愿，大家沉默了一会，她挑了一个人。然后我申请第二个。有两个同学介绍了自己的研究内容，一大堆也没听懂说的什么，然后最后一名同学就应该是吸取了经验，也点出来自己就不再介绍那些研究内容了，也跟我一样提了对数据分析的热爱与了解，所以最让我觉得有点竞争力的也就是这位同学了，整场面试下来，她给我最大的印象就是，学霸、说话很有条理、沉着冷静（比较让人有信服感）、气质也是比较沉稳挂的。我要向她学习 ！</p>
<p>一共两次小组讨论。每次讨论半小时左右。</p>
<p>我先提出想当记录员（后来我觉得我应该去争取小组长orz）</p>
<h1 id="Round-1-小红书-amp-指标体系"><a href="#Round-1-小红书-amp-指标体系" class="headerlink" title="Round 1. 小红书&amp;指标体系"></a>Round 1. 小红书&amp;指标体系</h1><p>主题：为小红书这个产品设计一套指标体系。</p>
<p>内容：先给5min了解这个产品，然后讨论30min，总结发言。</p>
<p>我自己大概用小红书前前后后的时间有一个月，其他人表示不了解这个产品。</p>
<p>（个人认为，即使平时不用这个APP，但作为一名想从业数据分析方向的人，对一些比较火热的互联网产品还是要有认知的。就像我不是抖音快手用户 ，但也会被潮流裹挟着了解一二，并且站在数据分析的角度更要有学习和思考。）</p>
<h2 id="小组讨论"><a href="#小组讨论" class="headerlink" title="小组讨论"></a>小组讨论</h2><p>挑出当时记录的一些点——</p>
<ul>
<li>用户画像和收益指标<ul>
<li>用户规模和质量：<ul>
<li>活跃、新增、用户构成、</li>
<li><strong>日常监控</strong>：日活、访问、在线时长。生命周期的转化指标。</li>
</ul>
</li>
<li>收益指标<ul>
<li>付费产品的总人数，复购率。</li>
<li>产品本身的监控指标：产品转化漏斗，发文数量。</li>
<li>商城 订单。销售额，销售量，复购率。环比，同比，</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>讨论过程待补充。</p>
<h2 id="补充思考"><a href="#补充思考" class="headerlink" title="补充思考"></a>补充思考</h2><h3 id="产品定位"><a href="#产品定位" class="headerlink" title="产品定位"></a>产品定位</h3><p>小红书：用户可以通过短视频、图文等形式记录生活点滴，分享生活方式，并基于兴趣形成互动，是年轻人的生活方式平台。主要为年轻女性提供可分享护肤美妆、时尚穿搭、明星等18个话题内容的社区交流平台，同时为没有明确购物目标的用户提供内容服务，帮助他们做购物决策，养成用户消费需求。</p>
<p>类型：内容型电商平台。也可以理解：以内容连接消费者和商品的电商模式，使得消费者通过内容的建议和指引而实现消费。</p>
<p>功能：</p>
<ul>
<li>社区（UGC内容）：时尚、个护、美妆、美食、旅行、娱乐、读书、健身、母婴等领域。</li>
<li>企业号（To B）：连接消费者和品牌，帮助品牌完成一站式闭环<a href="https://www.iyunying.org/yxzs">营销</a>，提供全链条服务。</li>
<li>福利社（跨境电商平台）自营电商平台，销售来自全世界的优质美妆、时尚、家电、零食商品。</li>
</ul>
<h3 id="用户需求分析"><a href="#用户需求分析" class="headerlink" title="用户需求分析"></a>用户需求分析</h3><h4 id="用户画像"><a href="#用户画像" class="headerlink" title="用户画像"></a>用户画像</h4><p>性别、年龄、地域、偏好、消费水平</p>
<h3 id="盈利指标分析"><a href="#盈利指标分析" class="headerlink" title="盈利指标分析"></a>盈利指标分析</h3><h4 id="盈利模式"><a href="#盈利模式" class="headerlink" title="盈利模式"></a>盈利模式</h4><p>用户以年轻女性为主，</p>
<ul>
<li>平台费：自营供应商、第三方店铺入驻需要给产品的平台费（大头）</li>
<li>广告费：品牌方通过软文的形式在平台发布商业推广广告，很多品牌方都是委托大V在社区中推荐商品，有些会和平台形成长期的合作。</li>
<li>海外直采的差价：团队与海外品牌合作，低价采进商品在自营店铺中售卖，通过保税仓发货给国内用户，赚取中间差价</li>
<li>独立品牌店铺</li>
</ul>
<h4 id="指标体系"><a href="#指标体系" class="headerlink" title="指标体系"></a>指标体系</h4><p>小红书APP三个最主要的行为：发布内容、浏览内容、下单购买。通过用户行为分析相关指标。小红书主要有两种用户：内容生产者、内容浏览者。</p>
<h5 id="内容生产者"><a href="#内容生产者" class="headerlink" title="内容生产者"></a>内容生产者</h5><p>构建指标衡量 好的内容生产者、内容生产者的活跃度、生产内容的质量。</p>
<table>
<thead>
<tr>
<th align="center">指标</th>
<th align="center">衡量对象</th>
<th align="center">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">关注量、粉丝量、pv、uv</td>
<td align="center">优质内容生产者</td>
<td align="center">给予流量曝光和平台分成，激励其再次成为好的内容生产者</td>
</tr>
<tr>
<td align="center">图文偏好、类目偏好、发布数量及发布频率、评论回复数及回复频率、笔记修改次数及修改频率</td>
<td align="center">内容生产者的活跃度</td>
<td align="center">确保APP内容<a href="https://www.iyunying.org/">运营</a>的正常运转</td>
</tr>
<tr>
<td align="center">被收藏、被点赞、被评论、被分享、重复访问量、下单率、客单价</td>
<td align="center">生产内容的质量</td>
<td align="center">好的内容质量才能不断提升APP的使用粘性</td>
</tr>
</tbody></table>
<h5 id="内容浏览者"><a href="#内容浏览者" class="headerlink" title="内容浏览者"></a>内容浏览者</h5><p>主要目的：实现精准推送，增加用户粘性</p>
<table>
<thead>
<tr>
<th align="center">指标</th>
<th align="center">衡量对象</th>
<th align="center">目的</th>
</tr>
</thead>
<tbody><tr>
<td align="center">搜索访问量占比、页面偏好、访问时间段分布、访问次数及频率、平均停留时间、人均页面访问量、跳出率、退出率</td>
<td align="center">用户偏好</td>
<td align="center">用户画像，实现精准推送</td>
</tr>
<tr>
<td align="center">点赞、评论、关注、分享、下单次数、客单价、回访时间间隔</td>
<td align="center">用户活跃</td>
<td align="center">用户画像，确保用户质量</td>
</tr>
<tr>
<td align="center">下载量、注册量及转化率、登录人数、下载来源、注册渠道</td>
<td align="center">用户体量</td>
<td align="center">用户画像</td>
</tr>
</tbody></table>
<p>待补充。。在高铁上，姿势有点累。</p>
<h1 id="Round-2-小红书-amp-活动评估"><a href="#Round-2-小红书-amp-活动评估" class="headerlink" title="Round 2. 小红书&amp;活动评估"></a>Round 2. 小红书&amp;活动评估</h1><p>主题：为小红书策划一次“红人节”活动，并设计指标对活动效果评估。活动主题可自拟。</p>
<h2 id="小组讨论-1"><a href="#小组讨论-1" class="headerlink" title="小组讨论"></a>小组讨论</h2><p>这一次组员内产生的分歧比较大。主要有两个方面：</p>
<p>1、有组员认为：重点应该在活动内容设计上，确定了好的活动内容，才有目标。</p>
<p>2、有组员认为：应该对活动的策略进行一次AB测试，选取效果最好的一组。</p>
<p>这两个我都不赞同</p>
<p>对第一点：首先，题目我记的可能不是很标准，但我认为这个重点绝对是在设计指标评估活动效果上，我之前也见过类似的面试题。设计活动内容主要是运营的工作吧。</p>
<p>对第二点：</p>
<p>1、同上，活动的目的才是我们首先要确定的，内容/策略不是重点，整个讨论应该围绕两点 1、确定活动目的。2、设计评估指标。</p>
<p>2、AB测试是为了推动业务决策，比如某一项功能是否上线、某个图标、按钮的改动等。如果要确定什么活动策略效果更好，我们数据分析师更要去关心如何评估活动效果不是么？</p>
<p>所以整个讨论浪费了挺多时间在这两点上。</p>
<p>经过第一次讨论后，我的状态好了一点，不那么紧张了。尽管我一开始就单刀直入：先确定活动目的吧，拉新？促活？清库存？我建议拉新。</p>
<p>然后就确定活动内容讨论了一会。。。我也很遗憾只想到两点：</p>
<p>1、针对新用户：日增、日活、留存、渠道转化率、环比对比、同比对比</p>
<p>2、针对小红书的社区类型：统计每日比较火热的（赞、评、转、收藏）帖子数量趋势。（由组员启发）</p>
<p>所以这一次我要求汇报。但是我的演讲汇报能力有待提高，这是我的一个短板，冲冲冲，加油鸭！</p>
<p>一定要注意两点：1、条理要清晰。2、语速慢一点【捂脸】</p>
<h2 id="补充思考-1"><a href="#补充思考-1" class="headerlink" title="补充思考"></a>补充思考</h2><p>（1） 确定大促的目的：拉新？促活？清库存？<br>（2） 根据目的确定核心指标。<br>（3） 效果评估：<br>a. 自身比较：活动前与活动中比较<br>b. 与预定目标比<br>c. 与同期其它活动比<br>d. 与往期同类活动比<br>（4）持续监控：<br>a. 检查活动后情况，避免透支消费情况发生<br>b. 如果是拉新等活动，根据后续数据检验这批新客的质量</p>
<p>先这么多。。</p>
<hr>
<h2 id="反思与收获"><a href="#反思与收获" class="headerlink" title="反思与收获"></a>反思与收获</h2><p>1、个人的语言表达/演讲/汇报能力有待提高，我知道神策的这个数分岗，对这一点还是很看重的，希望在这次面试中我不会被这点拉后腿。</p>
<p>2、既然是以小组讨论的形式，以下几点就一定要注意：</p>
<ul>
<li>觉得自己有能力胜任组长一职的，要先去争取。首先组长对整个讨论的局面把控、结果输出都很有影响，我想面试官不仅看个人表现也更注重整体结果！</li>
<li>不要刻意表现自己。确实，会想表现自己“我在这方面的知识素养不错”。但一定不要拉踩别人、要贴题点题。</li>
<li>明白自己的擅长所在，要扬长避短，也要学会为自己争取。</li>
</ul>
<p>3、对讨论的主题有点大意。明明知道这个岗位很注重数分业务知识、且是就一个问题小组讨论的形式，应该是可以猜到大概的。所以准备不充分，还好之前也看过很多有关业务指标体系的文章，有点积累，不过还没沉淀成自己的。</p>
<p>暂时想到这么多。</p>
<hr>
]]></content>
      <tags>
        <tag>数据分析</tag>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>滴滴SQL题</title>
    <url>/2021-01-01-%E6%BB%B4%E6%BB%B4SQL%E9%A2%98/</url>
    <content><![CDATA[<h1 id="滴滴笔试题"><a href="#滴滴笔试题" class="headerlink" title="滴滴笔试题"></a>滴滴笔试题</h1><p>1、 假设某天用户发单量异常，如何分析？</p>
<p>分析这一天的环比、同比数据；这一天是工作日、周末、还是节假日；由于设备还是服务器什么的原因；发生地点？对比其他地点；客群分析</p>
<p>2、 上海虹桥站，6月司机应答后取消率高于去年同期（其他火车站无此现象），如何分析？</p>
<p>环比数据；六月所有数据具体到天、小时；查看机场的异常情况（因为虹桥站跟机场在一起）；跟其他城市对比；查看是谁取消的，司机/用户，by应答时间</p>
<p><a href="https://baijiahao.baidu.com/s?id=1683757374866084787&wfr=spider&for=pc">业务数据分析方法之<strong>异常数据如何分析</strong></a></p>
<p>3、表名：dw_v_order_base</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>order_id</td>
<td>订单编号</td>
</tr>
<tr>
<td>pid</td>
<td>乘客编号</td>
</tr>
<tr>
<td>driver_id</td>
<td>司机编号</td>
</tr>
<tr>
<td>finish_time</td>
<td>完单时间（格式为2019-07-08  17:20:58）</td>
</tr>
<tr>
<td>product_id</td>
<td>完单类型（3,4为快车）</td>
</tr>
<tr>
<td>order_status</td>
<td>订单状态（5为完成订单，7为被取消订单）</td>
</tr>
<tr>
<td>city_name</td>
<td>城市名称</td>
</tr>
<tr>
<td>distance</td>
<td>订单实际距离（单位：km）</td>
</tr>
</tbody></table>
<p>表名：dm.gulf_order_scene</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>order_id</td>
<td>订单编号</td>
</tr>
<tr>
<td>scene_l2</td>
<td>订单场景（‘去火车站’、‘火车站出发’为火车站场景订单）</td>
</tr>
</tbody></table>
<h2 id="分区的乘客数分布"><a href="#分区的乘客数分布" class="headerlink" title="分区的乘客数分布"></a>分区的乘客数分布</h2><p>1）请写出过去一周火车站场景下快车完单量、完单城市关于乘客数分布；</p>
<p>（说明：快车完单数1单 2单 单。。。完单城市北京，上海，深圳。。各情况对应的用户数是多少）</p>
<ul>
<li> <strong>筛选日期</strong>：<code>subdate(curdate(),interval 7 day)</code>；<strong>筛选场景</strong>：<code>scene_l2  like &#39;%火车站%&#39;</code>  ；<strong>筛选类型</strong>是快车；<strong>筛选订单状态</strong>是完单</li>
<li> 按照<strong>乘客和城市分组</strong>，计算每个城市各个乘客的快车完单量 <code>count(distinct order_id)</code></li>
<li> 再按照<strong>完单量和城市分组</strong>，得到相应的用户数<code>count(pid)</code></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 完单数,city_name,<span class="built_in">count</span>(pid)乘客数 </span><br><span class="line"><span class="keyword">from</span>(<span class="keyword">select</span> pid,city_name, <span class="built_in">count</span>(<span class="keyword">distinct</span> d.order_id)完单数 </span><br><span class="line"><span class="keyword">from</span> dw_v_order_base d <span class="keyword">left</span> <span class="keyword">join</span> gulf_order_scene g <span class="keyword">on</span> d.order_id <span class="operator">=</span> g.order_id</span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(finish_time) <span class="operator">&gt;</span> date_sub(curdate(),<span class="type">interval</span> <span class="number">7</span> <span class="keyword">day</span>)</span><br><span class="line"><span class="keyword">and</span> g.scene_l2 <span class="keyword">like</span> <span class="string">&#x27;%火车站%&#x27;</span> <span class="keyword">and</span> d.product_id <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">and</span> d.order_status <span class="operator">=</span><span class="number">5</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> pid,city_name)t</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> 完单数,city_name;</span><br></pre></td></tr></table></figure>
<p><img src="../images/1.png"></p>
<h2 id="分里程时段的订单量分布"><a href="#分里程时段的订单量分布" class="headerlink" title="分里程时段的订单量分布"></a>分里程时段的订单量分布</h2><p>2）请写出过去一个月各城市分里程分时段快车完单量的分布；（无从得知怎么对时段里程分区的情况下，按照滴滴的产品计费规则理解）</p>
<ul>
<li><strong>筛选日期</strong>：<code>subdate(curdate(),interval 1 month)</code>；<strong>筛选类型</strong>是快车；<strong>筛选订单状态</strong>是完单</li>
<li>时段分组 6-21是普通时段，其余是特殊时段；里程分组：0-8,8-15,15-40,40以上；在select里查询为单独列</li>
<li>然后按照<strong>城市，里程区间，时段区间分组</strong></li>
<li>计算每个分组里的订单量</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> city_name,</span><br><span class="line">	   if(distance<span class="operator">&lt;=</span><span class="number">8</span>,<span class="string">&#x27;0-8公里&#x27;</span>,if(distance<span class="operator">&lt;=</span><span class="number">15</span>,<span class="string">&#x27;8-15公里&#x27;</span>,if(distance<span class="operator">&lt;=</span><span class="number">40</span>,<span class="string">&#x27;15-40公里&#x27;</span>,<span class="string">&#x27;40公里以上&#x27;</span>))) 里程,</span><br><span class="line">       if(<span class="keyword">hour</span>(finish_time)<span class="operator">&gt;=</span><span class="number">6</span> <span class="keyword">and</span> <span class="keyword">hour</span>(finish_time)<span class="operator">&lt;</span><span class="number">21</span>,<span class="string">&#x27;普通时段&#x27;</span>,<span class="string">&#x27;特殊时段&#x27;</span>) 时段,</span><br><span class="line">       <span class="built_in">count</span>(<span class="keyword">distinct</span> order_id)快车完单量</span><br><span class="line"><span class="keyword">from</span> dw_v_order_base d </span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(finish_time) <span class="operator">&gt;</span> date_sub(curdate(),<span class="type">interval</span> <span class="number">1</span> <span class="keyword">month</span>)</span><br><span class="line"><span class="keyword">and</span> d.product_id <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">and</span> d.order_status <span class="operator">=</span><span class="number">5</span></span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> city_name,if(distance<span class="operator">&lt;=</span><span class="number">8</span>,<span class="string">&#x27;0-8公里&#x27;</span>,if(distance<span class="operator">&lt;=</span><span class="number">15</span>,<span class="string">&#x27;8-15公里&#x27;</span>,if(distance<span class="operator">&lt;=</span><span class="number">40</span>,<span class="string">&#x27;15-40公里&#x27;</span>,<span class="string">&#x27;40公里以上&#x27;</span>))),if(<span class="keyword">hour</span>(finish_time)<span class="operator">&gt;=</span><span class="number">6</span> <span class="keyword">and</span> <span class="keyword">hour</span>(finish_time)<span class="operator">&lt;</span><span class="number">21</span>,<span class="string">&#x27;普通时段&#x27;</span>,<span class="string">&#x27;特殊时段&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p><img src="../images/2.png"> </p>
<h2 id="日留存率"><a href="#日留存率" class="headerlink" title="日留存率"></a>日留存率</h2><p>3）2020-05-01快车完单用户在之后一周内日留存率；</p>
<ul>
<li><strong>筛选日期</strong>：<code>date(finish_time) between&#39;2020-05-01&#39; and &#39;2020-05-08&#39;</code>；<strong>筛选类型</strong>是快车；<strong>筛选订单状态</strong>是完单；得到符合以上条件的<strong>用户u</strong></li>
<li><strong>在用户u的基础上</strong>，<strong>筛选日期</strong><code>date(finish_time) between&#39;2020-05-02&#39; and &#39;2020-05-08&#39;</code> ，<strong>按照完单日期分组</strong>，用<strong>每个完单日期与05-01的差</strong>得到留存天数，对每个分组内的用户数计数得到<strong>日留存用户数</strong></li>
<li><strong>日留存率 = 日留存用户数/05-01的总用户数</strong> </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 2020-05-01快车完单总用户数</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> pid <span class="keyword">from</span> dw_v_order_base d </span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(d.finish_time)<span class="operator">=</span><span class="string">&#x27;2020-05-01&#x27;</span> <span class="keyword">and</span> d.product_id <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">and</span> d.order_status <span class="operator">=</span><span class="number">5</span>;</span><br><span class="line"><span class="comment">-- 2020-05-02至2020-05-08的日留存率</span></span><br><span class="line"><span class="keyword">select</span> timestampdiff(<span class="keyword">day</span>,<span class="string">&#x27;2020-05-01&#x27;</span>,<span class="type">date</span>(d.finish_time)) 留存天数,</span><br><span class="line">	  <span class="built_in">count</span>(<span class="keyword">distinct</span> d.pid) 留存用户数,</span><br><span class="line">      <span class="built_in">count</span>(<span class="keyword">distinct</span> d.pid)<span class="operator">/</span>(<span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> pid) <span class="keyword">from</span> dw_v_order_base d </span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(d.finish_time)<span class="operator">=</span><span class="string">&#x27;2020-05-01&#x27;</span> <span class="keyword">and</span> d.product_id <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">and</span> d.order_status <span class="operator">=</span><span class="number">5</span>)留存率</span><br><span class="line"><span class="keyword">from</span> dw_v_order_base d </span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(d.finish_time) <span class="keyword">between</span> <span class="string">&#x27;2020-05-02&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;2020-05-08&#x27;</span></span><br><span class="line"><span class="keyword">and</span> d.pid <span class="keyword">in</span> (<span class="keyword">select</span> <span class="keyword">distinct</span> pid <span class="keyword">from</span> dw_v_order_base d </span><br><span class="line"><span class="keyword">where</span> <span class="type">date</span>(d.finish_time)<span class="operator">=</span><span class="string">&#x27;2020-05-01&#x27;</span> <span class="keyword">and</span> d.product_id <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>) <span class="keyword">and</span> d.order_status <span class="operator">=</span><span class="number">5</span>)</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> <span class="type">date</span>(d.finish_time);</span><br></pre></td></tr></table></figure>
<p><img src="../images/3.png"></p>
<h2 id="连续完单天数最长"><a href="#连续完单天数最长" class="headerlink" title="连续完单天数最长"></a>连续完单天数最长</h2><p>4）选出各城市连续完单天数最长的快车司机（加分题）；</p>
<ul>
<li><strong>筛选类型</strong>是快车；<strong>筛选订单状态</strong>是完单，查找不重复城市、司机、完单日期（也可以按照城市、司机、完单日期分组）得到t1</li>
<li>在t1上，对每个城市，每个司机的订单日期使用开窗函数，按照城市、司机进行排序，再用每个完单日期减去排序值，得到的分组日期可以<strong>对连续日期分组</strong>，得到t2</li>
<li>在t2上，对城市、司机、分组日期进行分组，对每一行都进行最大连续日期的计算（用开窗函数按照城市分组），再与每个司机的连续完单日期进行对比，匹配到该城市完成最大连续日期的司机是谁。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">	city_name,</span><br><span class="line">    driver_id,</span><br><span class="line">    司机连续完单天数</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> </span><br><span class="line">	city_name,</span><br><span class="line">    driver_id,</span><br><span class="line">    分组日期,</span><br><span class="line">    <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> 司机连续完单天数,</span><br><span class="line">    <span class="built_in">max</span>(<span class="built_in">count</span>(<span class="operator">*</span>)) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> city_name) <span class="keyword">as</span> 城市最长连续完单天数</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> </span><br><span class="line">	<span class="operator">*</span>,</span><br><span class="line">    <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> city_name,driver_id <span class="keyword">order</span> <span class="keyword">by</span> 完单日期) <span class="keyword">as</span> 序号,</span><br><span class="line">    subdate(完单日期,<span class="type">interval</span> <span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> city_name,driver_id <span class="keyword">order</span> <span class="keyword">by</span> 完单日期) <span class="keyword">day</span>) <span class="keyword">as</span> 分组日期</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">distinct</span> city_name,driver_id,<span class="type">date</span>(finish_time) <span class="keyword">as</span> 完单日期</span><br><span class="line"><span class="keyword">from</span> dw_v_order_base) <span class="keyword">as</span> t1) <span class="keyword">as</span> t2</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> city_name,driver_id,分组日期) <span class="keyword">as</span> t3</span><br><span class="line"><span class="keyword">where</span> 司机连续完单天数<span class="operator">=</span>城市最长连续完单天数;</span><br></pre></td></tr></table></figure>
<p><img src="../images/4.png"></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>酒店预订平台用户流失概率预测</title>
    <url>/2021-01-11-Prediction_of_User_Churn/</url>
    <content><![CDATA[<h1 id="酒店预订平台用户流失概率预测"><a href="#酒店预订平台用户流失概率预测" class="headerlink" title="酒店预订平台用户流失概率预测"></a>酒店预订平台用户流失概率预测</h1><h2 id="1、项目介绍"><a href="#1、项目介绍" class="headerlink" title="1、项目介绍"></a>1、项目介绍</h2><p>某酒店预订平台所属公司作为中国领先的综合性旅行服务公司，每天向超过2.5亿会员提供全方位的旅行服务，在这海量的网站访问量中，我们可分析用户的行为数据来挖掘潜在的信息资源。其中，客户流失率是考量业务成绩的一个非常关键的指标。此次分析的目的是为了<strong>深入了解用户画像及行为偏好，找到最优算法，挖掘出影响用户流失的关键因素</strong>，从而更好地完善产品设计、提升用户体验！</p>
<ul>
<li><p>目的<br>分析影响客户流失的关键因素，并通过算法预测客户访问的转化结果。</p>
</li>
<li><p>评估标准<br>评分指标为97%精确度下的召回率，即：在precision&gt;=0.97的情况下，得到最大的recall值。</p>
</li>
<li><p>数据集<br>数据集包括49个指标（2016年5月16至21日期间一周的数据），689945行，预测的目标样本为流失样本(即label=1)，将这些指标按订单相关、酒店相关和客户行为相关进行归类。</p>
<p><img src="../images/19.png"></p>
</li>
</ul>
<h2 id="2、项目流程"><a href="#2、项目流程" class="headerlink" title="2、项目流程"></a>2、项目流程</h2><h3 id="2-1-数据预处理"><a href="#2-1-数据预处理" class="headerlink" title="2.1 数据预处理"></a>2.1 数据预处理</h3><h4 id="2-1-1-目标特征分布"><a href="#2-1-1-目标特征分布" class="headerlink" title="2.1.1 目标特征分布"></a>2.1.1 目标特征分布</h4><p>导入相应包和数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> preprocessing</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler,OneHotEncoder</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> StratifiedKFold</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">df_orign = pd.read_csv(<span class="string">&#x27;userlostprob_train.txt&#x27;</span>, sep=<span class="string">&#x27;\t&#x27;</span>)</span><br><span class="line">df = df_orign.copy()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In[<span class="number">1</span>]: df[<span class="string">&#x27;label&#x27;</span>].value_counts()</span><br><span class="line">Out[<span class="number">1</span>]: </span><br><span class="line"><span class="number">0</span>    <span class="number">500588</span></span><br><span class="line"><span class="number">1</span>    <span class="number">189357</span></span><br><span class="line">Name: label, dtype: int64</span><br></pre></td></tr></table></figure>
<p>流失和未流失的用户比例<strong>2:5</strong>，样本不是非常不平衡，所以不做处理。</p>
<p>但也可以处理，这里想到两个方法：</p>
<p>1、对小类样本错分进行加权惩罚</p>
<p>2、数据重采样（大样本欠采样，小样本过采样）</p>
<h4 id="2-1-2-处理异常值"><a href="#2-1-2-处理异常值" class="headerlink" title="2.1.2 处理异常值"></a>2.1.2 处理异常值</h4><p><strong>1、负值</strong></p>
<ul>
<li>用户偏好价格delta_price1(132816条)、delta_price2(134606条)，以及当前酒店可订最低价lowestprice(1条)，理论上酒店的价格不可能为负，考虑到可能是因为优惠折扣的原因，因此<strong>采取0填充</strong>。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;delta_price1&#x27;</span>,<span class="string">&#x27;delta_price2&#x27;</span>,<span class="string">&#x27;lowestprice&#x27;</span>]] = df[[<span class="string">&#x27;delta_price1&#x27;</span>,<span class="string">&#x27;delta_price2&#x27;</span>,<span class="string">&#x27;lowestprice&#x27;</span>]].applymap(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> x)</span><br></pre></td></tr></table></figure>
<ul>
<li>客户价值customer_value_profit、ctrip_profits为负值，一开始我觉得肯定出错，后来思考加搜索得出：用户价值可以为负，如果一个用户的行为，导致其他用户的极大反感，并造成了其他用户的流失和粘性下降，就是用户的负面价值。典型如喷子，杠精，游戏中的外挂用户等。<strong>所以这里不作处理</strong></li>
</ul>
<ul>
<li>deltaprice_pre2_t1是酒店价格与对手价差均值，可以为负值，<strong>无需处理</strong>。</li>
</ul>
<p><strong>2、异常值</strong></p>
<p>24小时内登陆时长内登录时长不应该超过24小时，将大于24的值改为24</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ano_values1=[<span class="string">&#x27;delta_price1&#x27;</span>,<span class="string">&#x27;delta_price2&#x27;</span>,<span class="string">&#x27;lowestprice&#x27;</span>]</span><br><span class="line">ano_values2=[<span class="string">&#x27;customer_value_profit&#x27;</span>,<span class="string">&#x27;ctrip_profits&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ano_values1:</span><br><span class="line">    df.loc[df[col]&lt;<span class="number">0</span>,col]=df[col].median()  <span class="comment"># 填充中位数</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> ano_values2:</span><br><span class="line">    df.loc[df[col]&lt;<span class="number">0</span>,col]=<span class="number">0</span>  <span class="comment"># 填充0</span></span><br><span class="line"></span><br><span class="line">df.loc[df[<span class="string">&#x27;landhalfhours&#x27;</span>]&gt;<span class="number">24</span>,[<span class="string">&#x27;landhalfhours&#x27;</span>]] = <span class="number">24</span></span><br></pre></td></tr></table></figure>


<h4 id="2-1-3-处理缺失值"><a href="#2-1-3-处理缺失值" class="headerlink" title="2.1.3 处理缺失值"></a>2.1.3 处理缺失值</h4><p><strong>各个字段缺失值情况：</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">na_rate = (<span class="built_in">len</span>(df)-df.count())/<span class="built_in">len</span>(df)</span><br><span class="line">na_rate_order = na_rate.sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line">na_rate_order.head()</span><br><span class="line">Out[<span class="number">5</span>]: </span><br><span class="line">historyvisit_7ordernum              <span class="number">0.879824</span></span><br><span class="line">historyvisit_visit_detailpagenum    <span class="number">0.554698</span></span><br><span class="line">firstorder_bu                       <span class="number">0.453590</span></span><br><span class="line">decisionhabit_user                  <span class="number">0.441332</span></span><br><span class="line">historyvisit_totalordernum          <span class="number">0.439774</span></span><br><span class="line">dtype: float64</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>缺失值太多了，画图也看不清，知道第一位缺失87%可以直接删除了</p>
<p><strong>计算相关性</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_corr = df[df.columns.values.tolist()].corr()</span><br><span class="line">df_na = na_rate_order[na_rate_order&gt;<span class="number">0</span>].index.tolist()</span><br><span class="line"><span class="built_in">len</span>(df_na) <span class="comment">#有多少缺失值呢</span></span><br><span class="line">df_na_corr = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> df_na:</span><br><span class="line">    df_na_corr[i] = df_corr[i].sort_values(ascending=<span class="literal">False</span>)[[<span class="number">1</span>]]</span><br><span class="line">df_na_corr  <span class="comment">#查看这些缺失值互相的相关性</span></span><br></pre></td></tr></table></figure>
<p>1、字段’historyvisit_7ordernum ‘缺失程度太高，遂删去。</p>
<p>2、其他字段：这里通过查看它们的相关性、缺失程度、数据类型考虑以下几种填充办法</p>
<h5 id="2-1-3-1-用其他字段组合填充"><a href="#2-1-3-1-用其他字段组合填充" class="headerlink" title="2.1.3.1 用其他字段组合填充"></a>2.1.3.1 用其他字段组合填充</h5><p>这里的标准是，相关性高，字段取值一定程度上可以代替彼此，比如</p>
<p>commentnums_pre(24小时历史浏览次数最多酒店<strong>点评数</strong>)和novoters_pre(24小时历史浏览次数最多酒店<strong>评分人数</strong>)；commentnums_pre2(24小时历史浏览次数最多酒店<strong>点评数均值</strong>)和novoters_pre2(24小时历史浏览酒店<strong>评分人数均值</strong>)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;commentnums&#x27;</span>: novoters    <span class="number">0.992748</span></span><br><span class="line"><span class="string">&#x27;commentnums_pre2&#x27;</span>: novoters_pre2    <span class="number">0.985438</span></span><br><span class="line"><span class="comment"># 相关性都很高</span></span><br></pre></td></tr></table></figure>
<p>如何组合？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(df[<span class="string">&#x27;commentnums_pre&#x27;</span>]/df[<span class="string">&#x27;novoters_pre&#x27;</span>]).describe()</span><br><span class="line">Out[<span class="number">13</span>]: </span><br><span class="line">count    <span class="number">597927.000000</span></span><br><span class="line">mean          <span class="number">0.664643</span></span><br><span class="line">std           <span class="number">1.187749</span></span><br><span class="line"><span class="built_in">min</span>           <span class="number">0.000000</span></span><br><span class="line"><span class="number">25</span>%           <span class="number">0.538941</span></span><br><span class="line"><span class="number">50</span>%           <span class="number">0.656166</span></span><br><span class="line"><span class="number">75</span>%           <span class="number">0.733766</span></span><br><span class="line"><span class="built_in">max</span>         <span class="number">160.000000</span></span><br><span class="line">dtype: float64</span><br></pre></td></tr></table></figure>
<p>可以看到 二者的比值的中位数是 0.656166。可以理解为2/5=2.5 那么2*2.5可以==5, </p>
<p>5/2.5==2</p>
<p>所以就用novoters_prenovoters_pre*65% 填充 commentnums_pre；</p>
<p> commentnums_pre/65% 填充 novoters_prenovoters_pre</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 填充commentnums_pre和novoters_pre的部分缺失值，剩余缺失值用中位数填充。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_commentnum_novoter_pre</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (x.isnull()[<span class="string">&#x27;commentnums_pre&#x27;</span>])&amp;(x.notnull()[<span class="string">&#x27;novoters_pre&#x27;</span>]):</span><br><span class="line">        x[<span class="string">&#x27;commentnums_pre&#x27;</span>] = x[<span class="string">&#x27;novoters_pre&#x27;</span>]*<span class="number">0.65</span></span><br><span class="line">    <span class="keyword">elif</span> (x.notnull()[<span class="string">&#x27;commentnums_pre&#x27;</span>])&amp;(x.isnull()[<span class="string">&#x27;novoters_pre&#x27;</span>]):</span><br><span class="line">        x[<span class="string">&#x27;novoters_pre&#x27;</span>] = x[<span class="string">&#x27;commentnums_pre&#x27;</span>]/<span class="number">0.65</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">df[[<span class="string">&#x27;commentnums_pre&#x27;</span>,<span class="string">&#x27;novoters_pre&#x27;</span>]] = df[[<span class="string">&#x27;commentnums_pre&#x27;</span>,<span class="string">&#x27;novoters_pre&#x27;</span>]].apply(fill_commentnum_novoter_pre,axis=<span class="number">1</span>)</span><br><span class="line">df[[<span class="string">&#x27;commentnums_pre&#x27;</span>,<span class="string">&#x27;novoters_pre&#x27;</span>]].info()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 填充commentnums_pre2和novoters_pre2字段，剩余缺失值用均值填充。</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_commentnum_novoter_pre2</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> (x.isnull()[<span class="string">&#x27;commentnums_pre2&#x27;</span>])&amp;(x.notnull()[<span class="string">&#x27;novoters_pre2&#x27;</span>]):</span><br><span class="line">        x[<span class="string">&#x27;commentnums_pre2&#x27;</span>] = x[<span class="string">&#x27;novoters_pre2&#x27;</span>]*<span class="number">0.65</span></span><br><span class="line">    <span class="keyword">elif</span> (x.notnull()[<span class="string">&#x27;commentnums_pre2&#x27;</span>])&amp;(x.isnull()[<span class="string">&#x27;novoters_pre2&#x27;</span>]):</span><br><span class="line">        x[<span class="string">&#x27;novoters_pre2&#x27;</span>] = x[<span class="string">&#x27;commentnums_pre2&#x27;</span>]/<span class="number">0.65</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">df[[<span class="string">&#x27;commentnums_pre2&#x27;</span>,<span class="string">&#x27;novoters_pre2&#x27;</span>]] = df[[<span class="string">&#x27;commentnums_pre2&#x27;</span>,<span class="string">&#x27;novoters_pre2&#x27;</span>]].apply(fill_commentnum_novoter_pre2,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="2-1-3-2-均值、中位数、0填充"><a href="#2-1-3-2-均值、中位数、0填充" class="headerlink" title="2.1.3.2 均值、中位数、0填充"></a>2.1.3.2 均值、中位数、0填充</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#均值（极端值影响不大，符合近似正态分布的字段）</span></span><br><span class="line">fill_mean = [<span class="string">&#x27;cancelrate&#x27;</span>,<span class="string">&#x27;landhalfhours&#x27;</span>,<span class="string">&#x27;visitnum_oneyear&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>,<span class="string">&#x27;price_sensitive&#x27;</span>,<span class="string">&#x27;lowestprice&#x27;</span>,<span class="string">&#x27;customereval_pre2&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;uv_pre2&#x27;</span>,<span class="string">&#x27;lowestprice_pre2&#x27;</span>,<span class="string">&#x27;novoters_pre2&#x27;</span>,<span class="string">&#x27;commentnums_pre2&#x27;</span>,<span class="string">&#x27;businessrate_pre2&#x27;</span>,<span class="string">&#x27;lowestprice_pre&#x27;</span>,<span class="string">&#x27;hotelcr&#x27;</span>,<span class="string">&#x27;cancelrate_pre&#x27;</span>]</span><br><span class="line">df[fill_mean] = df[fill_mean].apply(<span class="keyword">lambda</span> x:x.fillna(x.mean()))</span><br><span class="line"><span class="comment">#中位数 (右偏分布的字段)</span></span><br><span class="line">fill_median = [<span class="string">&#x27;ordernum_oneyear&#x27;</span>,<span class="string">&#x27;commentnums_pre&#x27;</span>,<span class="string">&#x27;novoters_pre&#x27;</span>,<span class="string">&#x27;uv_pre&#x27;</span>,<span class="string">&#x27;ordercanncelednum&#x27;</span>,<span class="string">&#x27;ordercanceledprecent&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;lasthtlordergap&#x27;</span>,<span class="string">&#x27;cityuvs&#x27;</span>,<span class="string">&#x27;cityorders&#x27;</span>,<span class="string">&#x27;lastpvgap&#x27;</span>,<span class="string">&#x27;historyvisit_avghotelnum&#x27;</span>,<span class="string">&#x27;businessrate_pre&#x27;</span>,<span class="string">&#x27;cr&#x27;</span>,<span class="string">&#x27;uv_pre&#x27;</span>,<span class="string">&#x27;cr_pre&#x27;</span></span><br><span class="line">                ,<span class="string">&#x27;novoters_pre&#x27;</span>,<span class="string">&#x27;commentnums_pre&#x27;</span>,<span class="string">&#x27;novoters&#x27;</span>,<span class="string">&#x27;hoteluv&#x27;</span>,<span class="string">&#x27;ctrip_profits&#x27;</span>,<span class="string">&#x27;customer_value_profit&#x27;</span>]</span><br><span class="line">df[fill_median] = df[fill_median].apply(<span class="keyword">lambda</span> x:x.fillna(x.median()))</span><br><span class="line"><span class="comment">#0填充</span></span><br><span class="line">df[[<span class="string">&#x27;deltaprice_pre2_t1&#x27;</span>,<span class="string">&#x27;historyvisit_visit_detailpagenum&#x27;</span>]] = df[[<span class="string">&#x27;deltaprice_pre2_t1&#x27;</span>,<span class="string">&#x27;historyvisit_visit_detailpagenum&#x27;</span>]].apply(<span class="keyword">lambda</span> x:x.fillna(<span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<h5 id="2-1-3-3-用其他字段聚类自身分段填充"><a href="#2-1-3-3-用其他字段聚类自身分段填充" class="headerlink" title="2.1.3.3 用其他字段聚类自身分段填充"></a>2.1.3.3 用其他字段聚类自身分段填充</h5><p>填充consuming_capacity，其实这一步是为了得到完整的consuming_capacity然后填充与其相关性较强的avgprice</p>
<p>查看与consuming_capacity相关性高的特征：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">df_corr[&#39;consuming_capacity&#39;].sort_values(ascending&#x3D;False)[[0,1,2,3]]</span><br><span class="line">Out[14]: </span><br><span class="line">consuming_capacity    1.000000</span><br><span class="line">avgprice              0.880680</span><br><span class="line">starprefer            0.715734</span><br><span class="line">customereval_pre2     0.420362</span><br><span class="line">Name: consuming_capacity, dtype: float64</span><br></pre></td></tr></table></figure>
<p>所以可以用starprefer来尝试填充，先查看二者数据分布</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[[<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>]].describe()</span><br><span class="line">Out[<span class="number">15</span>]: </span><br><span class="line">       consuming_capacity     starprefer</span><br><span class="line">count       <span class="number">463837.000000</span>  <span class="number">689945.000000</span></span><br><span class="line">mean            <span class="number">39.154140</span>      <span class="number">67.532304</span></span><br><span class="line">std             <span class="number">23.240147</span>      <span class="number">15.740052</span></span><br><span class="line"><span class="built_in">min</span>              <span class="number">0.000000</span>       <span class="number">0.000000</span></span><br><span class="line"><span class="number">25</span>%             <span class="number">22.000000</span>      <span class="number">60.300000</span></span><br><span class="line"><span class="number">50</span>%             <span class="number">33.000000</span>      <span class="number">67.400000</span></span><br><span class="line"><span class="number">75</span>%             <span class="number">51.000000</span>      <span class="number">77.300000</span></span><br><span class="line"><span class="built_in">max</span>            <span class="number">100.000000</span>     <span class="number">100.000000</span></span><br><span class="line"></span><br><span class="line">df.loc[df[<span class="string">&#x27;starprefer&#x27;</span>]&lt;<span class="number">60</span>,[<span class="string">&#x27;onsuming_capacity&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>]].describe()</span><br><span class="line">Out[<span class="number">16</span>]: </span><br><span class="line">       onsuming_capacity     starprefer</span><br><span class="line">count       <span class="number">140364.000000</span>  <span class="number">382538.000000</span></span><br><span class="line">mean            <span class="number">20.522363</span>      <span class="number">44.282172</span></span><br><span class="line">std             <span class="number">10.048780</span>      <span class="number">10.091776</span></span><br><span class="line"><span class="built_in">min</span>              <span class="number">0.000000</span>       <span class="number">0.000000</span></span><br><span class="line"><span class="number">25</span>%             <span class="number">14.000000</span>      <span class="number">40.000000</span></span><br><span class="line"><span class="number">50</span>%             <span class="number">19.000000</span>      <span class="number">43.300000</span>   </span><br><span class="line"><span class="number">75</span>%             <span class="number">25.000000</span>      <span class="number">51.200000</span></span><br><span class="line"><span class="built_in">max</span>            <span class="number">100.000000</span>      <span class="number">59.900000</span></span><br><span class="line"></span><br><span class="line">df.loc[(df[<span class="string">&#x27;starprefer&#x27;</span>]&lt;<span class="number">80</span>)&amp;(df[<span class="string">&#x27;starprefer&#x27;</span>]&gt;=<span class="number">60</span>),[<span class="string">&#x27;onsuming_capacity&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>]].describe()</span><br><span class="line">Out[<span class="number">17</span>]: </span><br><span class="line">       onsuming_capacity    starprefer</span><br><span class="line">count       <span class="number">165204.000000</span>   <span class="number">43238.000000</span></span><br><span class="line">mean            <span class="number">35.670753</span>      <span class="number">67.671514</span>    </span><br><span class="line">std             <span class="number">14.504234</span>       <span class="number">4.092572</span></span><br><span class="line"><span class="built_in">min</span>              <span class="number">1.000000</span>      <span class="number">60.000000</span></span><br><span class="line"><span class="number">25</span>%             <span class="number">26.000000</span>      <span class="number">67.532304</span></span><br><span class="line"><span class="number">50</span>%             <span class="number">33.000000</span>      <span class="number">67.532304</span></span><br><span class="line"><span class="number">75</span>%             <span class="number">42.000000</span>      <span class="number">67.532304</span></span><br><span class="line"><span class="built_in">max</span>            <span class="number">100.000000</span>      <span class="number">79.900000</span></span><br><span class="line"></span><br><span class="line">df.loc[df[<span class="string">&#x27;starprefer&#x27;</span>]&gt;=<span class="number">80</span>,[<span class="string">&#x27;onsuming_capacity&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>]].describe()</span><br></pre></td></tr></table></figure>
<p>综上，用starprefe把consuming_capacity分成三个区间，每个区间内的空值用均值来填充。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 分段填充consuming_capacity</span></span><br><span class="line">fill1 = df.loc[df[<span class="string">&#x27;starprefer&#x27;</span>]&lt;<span class="number">60</span>,[<span class="string">&#x27;consuming_capacity&#x27;</span>]].mean()</span><br><span class="line">fill2 = df.loc[(df[<span class="string">&#x27;starprefer&#x27;</span>]&lt;<span class="number">80</span>)&amp;(df[<span class="string">&#x27;starprefer&#x27;</span>]&gt;=<span class="number">60</span>),[<span class="string">&#x27;consuming_capacity&#x27;</span>]].mean()</span><br><span class="line">fill3 = df.loc[df[<span class="string">&#x27;starprefer&#x27;</span>]&gt;=<span class="number">80</span>,[<span class="string">&#x27;consuming_capacity&#x27;</span>]].mean()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill_consuming_capacity</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x.isnull()[<span class="string">&#x27;consuming_capacity&#x27;</span>]:</span><br><span class="line">        <span class="keyword">if</span> x[<span class="string">&#x27;starprefer&#x27;</span>]&lt;<span class="number">60</span>:</span><br><span class="line">            x[<span class="string">&#x27;consuming_capacity&#x27;</span>] = fill1</span><br><span class="line">        <span class="keyword">elif</span> (x[<span class="string">&#x27;starprefer&#x27;</span>]&lt;<span class="number">80</span>)&amp;(x[<span class="string">&#x27;starprefer&#x27;</span>]&gt;=<span class="number">60</span>):</span><br><span class="line">            x[<span class="string">&#x27;consuming_capacity&#x27;</span>] = fill2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            x[<span class="string">&#x27;consuming_capacity&#x27;</span>] = fill3</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">df[[<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>]] = df[[<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>]].apply(fill_consuming_capacity,axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h5 id="2-1-3-4-用其他字段聚类填充"><a href="#2-1-3-4-用其他字段聚类填充" class="headerlink" title="2.1.3.4 用其他字段聚类填充"></a>2.1.3.4 用其他字段聚类填充</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df_corr[<span class="string">&#x27;commentnums&#x27;</span>].sort_values(ascending=<span class="literal">False</span>)[[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]]</span><br><span class="line">Out[<span class="number">18</span>]: </span><br><span class="line">commentnums    <span class="number">1.000000</span></span><br><span class="line">novoters       <span class="number">0.992748</span></span><br><span class="line">cancelrate     <span class="number">0.870245</span></span><br><span class="line">hoteluv        <span class="number">0.662154</span></span><br><span class="line">Name: commentnums, dtype: float64</span><br></pre></td></tr></table></figure>
<p>可看到commentnums和novoters、cancelrate、hoteluv存在较强相关性，可通过聚类取中位数的方式来填充commentnums。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 聚类填充commentnums</span></span><br><span class="line"><span class="comment">#commentnums：当前酒店点评数</span></span><br><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line">km = KMeans(n_clusters=<span class="number">4</span>)</span><br><span class="line">data = df.loc[:,[<span class="string">&#x27;commentnums&#x27;</span>,<span class="string">&#x27;novoters&#x27;</span>,<span class="string">&#x27;cancelrate&#x27;</span>,<span class="string">&#x27;hoteluv&#x27;</span>]]</span><br><span class="line">ss = StandardScaler()  <span class="comment"># 聚类算距离，需要先标准化</span></span><br><span class="line">data[[<span class="string">&#x27;novoters&#x27;</span>,<span class="string">&#x27;cancelrate&#x27;</span>,<span class="string">&#x27;hoteluv&#x27;</span>]] = pd.DataFrame(ss.fit_transform(data[[<span class="string">&#x27;novoters&#x27;</span>,<span class="string">&#x27;cancelrate&#x27;</span>,<span class="string">&#x27;hoteluv&#x27;</span>]]))</span><br><span class="line"></span><br><span class="line">km.fit(data.iloc[:,<span class="number">1</span>:])</span><br><span class="line">label_pred = km.labels_</span><br><span class="line">data[<span class="string">&#x27;label_pred&#x27;</span>] = label_pred</span><br><span class="line"><span class="comment">#metrics.calinski_harabaz_score(data.iloc[:,1:],km.labels_)</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;commentnums&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">0</span>),[<span class="string">&#x27;commentnums&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">0</span>,<span class="string">&#x27;commentnums&#x27;</span>]).median()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;commentnums&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">1</span>),[<span class="string">&#x27;commentnums&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">1</span>,<span class="string">&#x27;commentnums&#x27;</span>]).median()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;commentnums&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">2</span>),[<span class="string">&#x27;commentnums&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">2</span>,<span class="string">&#x27;commentnums&#x27;</span>]).median()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;commentnums&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">3</span>),[<span class="string">&#x27;commentnums&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">3</span>,<span class="string">&#x27;commentnums&#x27;</span>]).median()</span><br><span class="line">df[<span class="string">&#x27;commentnums&#x27;</span>] = data[<span class="string">&#x27;commentnums&#x27;</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同理，取starprefer和consuming_capacity聚类后每类avgprice的均值来填充avgprice的空值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#avgprice：starprefer,consuming_capacity</span></span><br><span class="line">km = KMeans(n_clusters=<span class="number">5</span>)</span><br><span class="line">data = df.loc[:,[<span class="string">&#x27;avgprice&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>,<span class="string">&#x27;consuming_capacity&#x27;</span>]]</span><br><span class="line">ss = StandardScaler()  <span class="comment"># 聚类算距离，需要先标准化</span></span><br><span class="line">data[[<span class="string">&#x27;starprefer&#x27;</span>,<span class="string">&#x27;consuming_capacity&#x27;</span>]] = pd.DataFrame(ss.fit_transform(data[[<span class="string">&#x27;starprefer&#x27;</span>,<span class="string">&#x27;consuming_capacity&#x27;</span>]]))</span><br><span class="line">km.fit(data.iloc[:,<span class="number">1</span>:])</span><br><span class="line">label_pred = km.labels_</span><br><span class="line">data[<span class="string">&#x27;label_pred&#x27;</span>] = label_pred</span><br><span class="line"><span class="comment">#metrics.calinski_harabaz_score(data.iloc[:,1:],km.labels_)</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;avgprice&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">0</span>),[<span class="string">&#x27;avgprice&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">0</span>,<span class="string">&#x27;avgprice&#x27;</span>]).mean()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;avgprice&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">1</span>),[<span class="string">&#x27;avgprice&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">1</span>,<span class="string">&#x27;avgprice&#x27;</span>]).mean()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;avgprice&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">2</span>),[<span class="string">&#x27;avgprice&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">2</span>,<span class="string">&#x27;avgprice&#x27;</span>]).mean()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;avgprice&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">3</span>),[<span class="string">&#x27;avgprice&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">3</span>,<span class="string">&#x27;avgprice&#x27;</span>]).mean()</span><br><span class="line">data.loc[(data[<span class="string">&#x27;avgprice&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">4</span>),[<span class="string">&#x27;avgprice&#x27;</span>]] = (data.loc[data[<span class="string">&#x27;label_pred&#x27;</span>] == <span class="number">4</span>,<span class="string">&#x27;avgprice&#x27;</span>]).mean()</span><br><span class="line">df[<span class="string">&#x27;avgprice&#x27;</span>] = data[<span class="string">&#x27;avgprice&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>取consuming_capacity和avgprice聚类后的中位数来填充delta_price1</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#delta_price1：consuming_capacity,avgprice</span></span><br><span class="line">km = KMeans(n_clusters=<span class="number">6</span>)</span><br><span class="line">data = df.loc[:,[<span class="string">&#x27;delta_price1&#x27;</span>,<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;avgprice&#x27;</span>]]</span><br><span class="line">ss = StandardScaler()  <span class="comment"># 聚类算距离，需要先标准化</span></span><br><span class="line">data[[<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;avgprice&#x27;</span>]] = pd.DataFrame(ss.fit_transform(data[[<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;avgprice&#x27;</span>]]))</span><br><span class="line"></span><br><span class="line">km.fit(data.iloc[:,<span class="number">1</span>:])</span><br><span class="line">label_pred = km.labels_</span><br><span class="line">data[<span class="string">&#x27;label_pred&#x27;</span>] = label_pred</span><br><span class="line"><span class="comment">#metrics.calinski_harabaz_score(data.iloc[:,1:],km.labels_)</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;delta_price1&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">0</span>),[<span class="string">&#x27;delta_price1&#x27;</span>]] = <span class="number">187</span><span class="comment">#data[&#x27;fill0&#x27;]</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;delta_price1&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">1</span>),[<span class="string">&#x27;delta_price1&#x27;</span>]] = <span class="number">100</span><span class="comment">#data[&#x27;fill1&#x27;]</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;delta_price1&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">2</span>),[<span class="string">&#x27;delta_price1&#x27;</span>]] = <span class="number">26</span><span class="comment">#data[&#x27;fill2&#x27;]</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;delta_price1&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">3</span>),[<span class="string">&#x27;delta_price1&#x27;</span>]] = <span class="number">1269</span><span class="comment">#data[&#x27;fill0&#x27;]</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;delta_price1&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">4</span>),[<span class="string">&#x27;delta_price1&#x27;</span>]] = <span class="number">323</span><span class="comment">#data[&#x27;fill0&#x27;]</span></span><br><span class="line">data.loc[(data[<span class="string">&#x27;delta_price1&#x27;</span>].isnull())&amp;(data[<span class="string">&#x27;label_pred&#x27;</span>]==<span class="number">5</span>),[<span class="string">&#x27;delta_price1&#x27;</span>]] = <span class="number">573</span><span class="comment">#data[&#x27;fill0&#x27;]</span></span><br><span class="line">df[<span class="string">&#x27;delta_price1&#x27;</span>] = data[<span class="string">&#x27;delta_price1&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>缺失值处理完毕。</p>
<h3 id="2-2-分析指标"><a href="#2-2-分析指标" class="headerlink" title="2.2 分析指标"></a>2.2 分析指标</h3><h4 id="2-2-1-客户分析"><a href="#2-2-1-客户分析" class="headerlink" title="2.2.1 客户分析"></a>2.2.1 客户分析</h4><p><strong>1、星级分布</strong></p>
<img src="../images/5.jpg" style="zoom:50%;" />

<p>大部分客户的星级偏好在[40，100]，并且有相当多的客户的星级偏好集中在40,60,80,100左右。</p>
<p><strong>2、客户价值分布</strong></p>
<img src="../images/6.jpg" style="zoom:50%;" />

<p>客户价值主要小于10，低价值客户占比较大。</p>
<p><strong>3、价格敏感指数分布</strong></p>
<img src="../images/7.jpg" style="zoom:50%;" />

<p>极值出现在数据两端， 大部分人对价格变动并不敏感，价格敏感指数为100时的人数也并不少，针对这一部分客户，可以考虑用一些打折优惠的方式吸引消费。</p>
<p><strong>4、客户消费能力指数</strong></p>
<img src="../images/8.jpg" style="zoom:50%;" />

<p>客户消费能力指数集中在[10，50]，其中在34左右的人群最多， 说明大部分消费人群消费能力中等，还有部分人群消费能力指数在接近100，属于高消费能力人群。</p>
<p><strong>5、访问时间点分布</strong></p>
<img src="../images/9.jpg" style="zoom:50%;" />

<p>凌晨1点到7点访问人数较少，在晚上10点访问最多，这一分布符合人们的入住习惯。</p>
<p><strong>6、新老客户占比及流失率</strong></p>
<img src="../images/10.jpg" style="zoom:50%;" />



<ul>
<li><p>94.42%的客户是老客户,新访客户仅占5.58%， 老客户是酒店客源的中坚力量</p>
</li>
<li><p>老客的流失率达到28%，新客的流失率占20%（与数量占比有关）， 需应该采取措施，谨防客户流失</p>
</li>
</ul>
<p><strong>7、用户订单数分布，预定和入住人数</strong></p>
<img src="../images/11.jpg" style="zoom:50%;" />

<img src="../images/12.jpg" style="zoom:50%;" />

<p>酒店的访问和入住人数在5月20日这一天达到峰值，是因为由于5月20日对于情侣有特殊的意义， 后续的酒店的入住人数有两个小高峰，对应的日期是周末的时间。</p>
<h4 id="2-2-2-酒店分析"><a href="#2-2-2-酒店分析" class="headerlink" title="2.2.2 酒店分析"></a>2.2.2 酒店分析</h4><p><strong>1、酒店价格分布</strong></p>
<img src="../images/13.jpg" style="zoom:50%;" />

<p>在客户选择的酒店里，大部分酒店的价格在1000元以内，100到400元价格区间内的数量最多，与客户消费能力指数趋势一致。</p>
<p><strong>2、酒店商务指数</strong></p>
<p>酒店商务指数分布图</p>
<img src="../images/14.png" style="zoom:80%;" />

<p>依据分布的分箱图</p>
<img src="../images/15.png" style="zoom:67%;" />

<ul>
<li>指数0.4以下:低</li>
<li>指数0.4~0.6:中</li>
<li>指数0.6~0.8:较高</li>
<li>指数0.8以上:高</li>
</ul>
<p>24小时<strong>已访问</strong>和<strong>浏览最多</strong>酒店,商务指数小于0.6(总指数为1), 占比超80%，考虑到商务性指数与价格相关度高，而大多数人的预期价格都比较低，所以商务型指数也不高。</p>
<h3 id="2-3-特征工程"><a href="#2-3-特征工程" class="headerlink" title="2.3 特征工程"></a>2.3 特征工程</h3><h4 id="2-3-1-新增字段"><a href="#2-3-1-新增字段" class="headerlink" title="2.3.1 新增字段"></a>2.3.1 新增字段</h4><ul>
<li>时间字段<br>新增字段：访问日期和入住日期间隔天数booking_gap、入住日期是星期几week_day、入住日期是否是周末is_weekend</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#格式为年-月-日</span></span><br><span class="line">df[[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;arrival&#x27;</span>]] = df[[<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;arrival&#x27;</span>]].apply(<span class="keyword">lambda</span> x:pd.to_datetime(x,<span class="built_in">format</span>=<span class="string">&#x27;%Y-%m-%d&#x27;</span>))</span><br><span class="line"><span class="comment">#访问日期和入住日期间隔天数</span></span><br><span class="line">df[<span class="string">&#x27;booking_gap&#x27;</span>] = ((df[<span class="string">&#x27;arrival&#x27;</span>]-df[<span class="string">&#x27;d&#x27;</span>])/np.timedelta64(<span class="number">1</span>,<span class="string">&#x27;D&#x27;</span>)).astype(<span class="built_in">int</span>)</span><br><span class="line"><span class="comment">#入住日期是星期几</span></span><br><span class="line">df[<span class="string">&#x27;week_day&#x27;</span>] = df[<span class="string">&#x27;arrival&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x.weekday())</span><br><span class="line"><span class="comment">#入住日期是否是周末</span></span><br><span class="line">df[<span class="string">&#x27;is_weekend&#x27;</span>] = df[<span class="string">&#x27;week_day&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>) <span class="keyword">else</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>是否是同一个样本【选取部分客户行为指标】<br>查看字段sid，发现95%都是老用户，新用户很少，一周内部分用户可能会下多个订单，为了<strong>方便后续划分训练集和验证集</strong>，避免使用其他用户的数据来预测一个用户。此处添加一个user_tag来区分是否是同一个用户的订单。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;user_tag&#x27;</span>] = df[<span class="string">&#x27;ordercanceledprecent&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;ordercanncelednum&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;ordernum_oneyear&#x27;</span>].<span class="keyword">map</span>(str) +\</span><br><span class="line">                  df[<span class="string">&#x27;starprefer&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;consuming_capacity&#x27;</span>].<span class="keyword">map</span>(str) + \</span><br><span class="line">                 df[<span class="string">&#x27;price_sensitive&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;customer_value_profit&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;ctrip_profits&#x27;</span>].<span class="keyword">map</span>(str) +df[<span class="string">&#x27;visitnum_oneyear&#x27;</span>].<span class="keyword">map</span>(str) + \</span><br><span class="line">                  df[<span class="string">&#x27;historyvisit_avghotelnum&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;businessrate_pre2&#x27;</span>].<span class="keyword">map</span>(str) +\</span><br><span class="line">                df[<span class="string">&#x27;historyvisit_visit_detailpagenum&#x27;</span>].<span class="keyword">map</span>(str) + \</span><br><span class="line">                  df[<span class="string">&#x27;delta_price2&#x27;</span>].<span class="keyword">map</span>(str) +  \</span><br><span class="line">                df[<span class="string">&#x27;commentnums_pre2&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;novoters_pre2&#x27;</span>].<span class="keyword">map</span>(str) +df[<span class="string">&#x27;customereval_pre2&#x27;</span>].<span class="keyword">map</span>(str) + df[<span class="string">&#x27;lowestprice_pre2&#x27;</span>].<span class="keyword">map</span>(str)</span><br><span class="line">df[<span class="string">&#x27;user_tag&#x27;</span>] = df[<span class="string">&#x27;user_tag&#x27;</span>].apply(lambda x : hash(x))</span><br><span class="line">df[<span class="string">&#x27;user_tag&#x27;</span>].unique().shape</span><br></pre></td></tr></table></figure>
<p>返回670226，即实际这周有670226个用户下过订单。</p>
<ul>
<li>用户字段和酒店字段<br>选取部分用户相关字段进行聚类创建用户字段user_group，选取部分酒店相关字段进行聚类创建酒店字段hotel_group。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">user_group = [<span class="string">&#x27;ordercanceledprecent&#x27;</span>,<span class="string">&#x27;ordercanncelednum&#x27;</span>,<span class="string">&#x27;ordernum_oneyear&#x27;</span>,</span><br><span class="line">             <span class="string">&#x27;historyvisit_visit_detailpagenum&#x27;</span>,<span class="string">&#x27;historyvisit_avghotelnum&#x27;</span>]</span><br><span class="line">hotel_group = [<span class="string">&#x27;commentnums&#x27;</span>, <span class="string">&#x27;novoters&#x27;</span>, <span class="string">&#x27;lowestprice&#x27;</span>, <span class="string">&#x27;hotelcr&#x27;</span>, <span class="string">&#x27;hoteluv&#x27;</span>, <span class="string">&#x27;cancelrate&#x27;</span>]</span><br><span class="line"><span class="comment">#聚类之前先标准化</span></span><br><span class="line">km_user = pd.DataFrame(df[user_group])</span><br><span class="line">km_hotel = pd.DataFrame(df[hotel_group])</span><br><span class="line">ss = StandardScaler()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(km_user.shape[<span class="number">1</span>]):</span><br><span class="line">    km_user[user_group[i]] = ss.fit_transform(df[user_group[i]].values.reshape(-<span class="number">1</span>, <span class="number">1</span>)).ravel()</span><br><span class="line">ss = StandardScaler()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(km_hotel.shape[<span class="number">1</span>]):</span><br><span class="line">    km_hotel[hotel_group[i]] = ss.fit_transform(df[hotel_group[i]].values.reshape(-<span class="number">1</span>, <span class="number">1</span>)).ravel()</span><br><span class="line">df[<span class="string">&#x27;user_group&#x27;</span>] = KMeans(n_clusters=<span class="number">3</span>).fit_predict(km_user)</span><br><span class="line"><span class="comment"># score = metrics.calinski_harabaz_score(km_user,KMeans(n_clusters=3).fit(km_user).labels_)</span></span><br><span class="line"><span class="comment"># print(&#x27;数据聚calinski_harabaz指数为：%f&#x27;%(score)) #3:218580.269018  4:218580.416497 5:218581.368953 6:218581.203569 </span></span><br><span class="line">df[<span class="string">&#x27;hotel_group&#x27;</span>] = KMeans(n_clusters=<span class="number">5</span>).fit_predict(km_hotel)</span><br><span class="line"><span class="comment"># score = metrics.calinski_harabaz_score(km_hotel,KMeans(n_clusters=3).fit(km_hotel).labels_)</span></span><br><span class="line"><span class="comment"># print(&#x27;数据聚calinski_harabaz指数为：%f&#x27;%(score))  #3：266853.481135  4:268442.314369 5:268796.468103 6:268796.707149</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-连续特征离散化"><a href="#2-3-2-连续特征离散化" class="headerlink" title="2.3.2 连续特征离散化"></a>2.3.2 连续特征离散化</h4><p>historyvisit_avghotelnum大部分都小于5，将字段处理成小于等于5和大于5的离散值；<br>ordercanncelednum大部分都小于5，将字段处理成小于等于5和大于5的离散值；<br>sid等于1是新访设为0，其他设为1为老用户。<br>avgprice、lowestprice、starprefer、consuming_capacity和h进行数值分段离散化。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df[<span class="string">&#x27;historyvisit_avghotelnum&#x27;</span>] = df[<span class="string">&#x27;historyvisit_avghotelnum&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x&lt;=<span class="number">5</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">df[<span class="string">&#x27;ordercanncelednum&#x27;</span>] = df[<span class="string">&#x27;ordercanncelednum&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x&lt;=<span class="number">5</span> <span class="keyword">else</span> <span class="number">1</span>)</span><br><span class="line">df[<span class="string">&#x27;sid&#x27;</span>] = df[<span class="string">&#x27;sid&#x27;</span>].apply(<span class="keyword">lambda</span> x: <span class="number">0</span> <span class="keyword">if</span> x==<span class="number">1</span> <span class="keyword">else</span> <span class="number">1</span>)  </span><br><span class="line"><span class="comment">#分段离散化</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discrete_avgprice</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;=<span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">400</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">600</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discrete_lowestprice</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;=<span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">300</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discrete_starprefer</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">80</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discrete_consuming_capacity</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">20</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">40</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;=<span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">discrete_h</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="keyword">if</span> x&gt;=<span class="number">0</span> <span class="keyword">and</span> x&lt;<span class="number">6</span>:<span class="comment">#凌晨访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;<span class="number">12</span>:<span class="comment">#上午访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> x&lt;<span class="number">18</span>:<span class="comment">#下午访问</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span><span class="comment">#晚上访问</span></span><br><span class="line">    </span><br><span class="line">df[<span class="string">&#x27;avgprice&#x27;</span>] = df[<span class="string">&#x27;avgprice&#x27;</span>].<span class="built_in">map</span>(discrete_avgprice)</span><br><span class="line">df[<span class="string">&#x27;lowestprice&#x27;</span>] = df[<span class="string">&#x27;lowestprice&#x27;</span>].<span class="built_in">map</span>(discrete_lowestprice)</span><br><span class="line">df[<span class="string">&#x27;starprefer&#x27;</span>] = df[<span class="string">&#x27;starprefer&#x27;</span>].<span class="built_in">map</span>(discrete_starprefer)</span><br><span class="line">df[<span class="string">&#x27;consuming_capacity&#x27;</span>] = df[<span class="string">&#x27;consuming_capacity&#x27;</span>].<span class="built_in">map</span>(discrete_consuming_capacity)</span><br><span class="line">df[<span class="string">&#x27;h&#x27;</span>] = df[<span class="string">&#x27;h&#x27;</span>].<span class="built_in">map</span>(discrete_h)</span><br></pre></td></tr></table></figure>
<p>对当前的数值型类别变量（定性特征）进行定性特征热编码（转化为定量特征），此处用OneHotEncoder方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">discrete_field = [<span class="string">&#x27;historyvisit_avghotelnum&#x27;</span>,<span class="string">&#x27;ordercanncelednum&#x27;</span></span><br><span class="line">                  ,<span class="string">&#x27;avgprice&#x27;</span>,<span class="string">&#x27;lowestprice&#x27;</span>,<span class="string">&#x27;starprefer&#x27;</span>,<span class="string">&#x27;consuming_capacity&#x27;</span>,<span class="string">&#x27;user_group&#x27;</span>,</span><br><span class="line">                 <span class="string">&#x27;hotel_group&#x27;</span>,<span class="string">&#x27;is_weekend&#x27;</span>,<span class="string">&#x27;week_day&#x27;</span>,<span class="string">&#x27;sid&#x27;</span>,<span class="string">&#x27;h&#x27;</span>]</span><br><span class="line">encode_df = pd.DataFrame(preprocessing.OneHotEncoder(handle_unknown=<span class="string">&#x27;ignore&#x27;</span>).fit_transform(df[discrete_field]).toarray())</span><br><span class="line">encode_df_new = pd.concat([df.drop(columns=discrete_field,axis=<span class="number">1</span>),encode_df],axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="2-3-3-删除字段"><a href="#2-3-3-删除字段" class="headerlink" title="2.3.3 删除字段"></a>2.3.3 删除字段</h4><p>去掉两类字段：<br>d、arrival、sampleid、firstorder_bu字段；<br>historyvisit_totalordernum和ordernum_oneyear这两个字段值相等，此处取ordernum_oneyear这个字段，删除historyvisit_totalordernum；<br>decisionhabit_user和historyvisit_avghotelnum数值较一致，此处选择historyvisit_avghotelnum，删除decisionhabit_user。</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">encode_df_new = encode_df_new.<span class="built_in">drop</span>(columns=[<span class="string">&#x27;d&#x27;</span>,<span class="symbol">&#x27;arrival</span><span class="string">&#x27;,&#x27;</span>sampleid<span class="string">&#x27;,&#x27;</span>historyvisit_totalordernum<span class="string">&#x27;,&#x27;</span>firstorder_bu<span class="string">&#x27;,&#x27;</span>decisionhabit_user&#x27;],axis=<span class="number">1</span>)</span><br><span class="line">encode_df_new.shape</span><br></pre></td></tr></table></figure>
<p>最终去除目标字段label和划分训练集字段user_tag，共有79个字段。</p>
<h3 id="2-3-模型训练"><a href="#2-3-模型训练" class="headerlink" title="2.3 模型训练"></a>2.3 模型训练</h3><h4 id="2-3-1-划分训练集和验证集"><a href="#2-3-1-划分训练集和验证集" class="headerlink" title="2.3.1 划分训练集和验证集"></a>2.3.1 划分训练集和验证集</h4><p>为了保证训练集和验证集独立同分布，将数据按照user_tag进行排序，取前70%作为训练集，剩余的作为验证集。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">ss_df_new = encode_df_new</span><br><span class="line"><span class="built_in">num</span> = ss_df_new.shape[<span class="number">0</span>]</span><br><span class="line">df_sort = ss_df_new.sort_values(by=[<span class="string">&#x27;user_tag&#x27;</span>],ascending=True)</span><br><span class="line">train_df = df_sort.iloc[:<span class="built_in">int</span>(<span class="built_in">num</span>*<span class="number">0.7</span>),:]</span><br><span class="line">test_df = df_sort.iloc[<span class="built_in">int</span>(<span class="built_in">num</span>*<span class="number">0.7</span>):,:]</span><br><span class="line">train_y = train_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">train_x = train_df.iloc[:,<span class="number">1</span>:]</span><br><span class="line">test_y = test_df[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">test_x = test_df.iloc[:,<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-比较各个模型的训练效果"><a href="#2-3-2-比较各个模型的训练效果" class="headerlink" title="2.3.2 比较各个模型的训练效果"></a>2.3.2 比较各个模型的训练效果</h4><p>所有模型的调参都采用GridSearchCV网格搜索进行。</p>
<ul>
<li>xgboost</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调整的参数：</span></span><br><span class="line"><span class="comment">#迭代器个数n_estimators</span></span><br><span class="line"><span class="comment">#min_child_weight以及max_depth</span></span><br><span class="line"><span class="comment">#gamma值</span></span><br><span class="line"><span class="comment">##subsample 和 colsample_bytree</span></span><br><span class="line"><span class="comment">#learning_rate，需要配合调整n_esgtimators</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> xgboost.sklearn <span class="keyword">import</span> XGBClassifier</span><br><span class="line">xgbc = XGBClassifier(learning_rate=<span class="number">0.05</span>, objective= <span class="string">&#x27;binary:logistic&#x27;</span>, nthread=<span class="number">1</span>,  scale_pos_weight=<span class="number">1</span>, seed=<span class="number">27</span>,</span><br><span class="line">                    subsample=<span class="number">0.6</span>, colsample_bytree=<span class="number">0.6</span>, gamma=<span class="number">0</span>, reg_alpha= <span class="number">0</span>, reg_lambda=<span class="number">1</span>,max_depth=<span class="number">38</span>,min_child_weight=<span class="number">1</span>,n_estimators=<span class="number">210</span>)</span><br><span class="line">xgbc.fit(train_x,train_y)</span><br><span class="line">predict_train = xgbc.predict_proba(train_x)[:,<span class="number">1</span>]</span><br><span class="line">predict_test = xgbc.predict_proba(test_x)[:,<span class="number">1</span>]</span><br><span class="line">pr_train,re_train,thre_train = metrics.precision_recall_curve(train_y,predict_train)</span><br><span class="line">pr_test,re_test,thre_test = metrics.precision_recall_curve(test_y,predict_test)</span><br><span class="line">auc_train = metrics.roc_auc_score(train_y,predict_train)</span><br><span class="line">auc_test = metrics.roc_auc_score(test_y,predict_test)</span><br><span class="line">prt_train = pd.DataFrame(&#123;<span class="string">&#x27;precision&#x27;</span>:pr_train,<span class="string">&#x27;recall&#x27;</span>:re_train&#125;)</span><br><span class="line">prt_test = pd.DataFrame(&#123;<span class="string">&#x27;precision&#x27;</span>:pr_test,<span class="string">&#x27;recall&#x27;</span>:re_test&#125;)</span><br><span class="line">print(<span class="string">&#x27;precision&gt;=0.97时对应的最大recall为：&#x27;</span>)</span><br><span class="line">print(prt_test.loc[prt_test[<span class="string">&#x27;precision&#x27;</span>]&gt;=<span class="number">0.97</span>,<span class="string">&#x27;recall&#x27;</span>].<span class="built_in">max</span>())</span><br><span class="line">print(<span class="string">&#x27;auc得分为：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(auc_test))</span><br></pre></td></tr></table></figure>
<p>precision&gt;=0.97时对应的最大recall为：<br>0.7435550716493396<br>auc得分为：0.9730951405840338）</p>
<ul>
<li>随机森林</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#调整的参数：</span></span><br><span class="line"><span class="comment">#n_estimators</span></span><br><span class="line"><span class="comment">#max_depth</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line">rf = RandomForestClassifier(n_estimators=<span class="number">300</span>,max_depth=<span class="number">50</span>)</span><br><span class="line">rf.fit(train_x,train_y)</span><br><span class="line">predict_train = rf.predict_proba(train_x)[:,<span class="number">1</span>]</span><br><span class="line">predict_test = rf.predict_proba(test_x)[:,<span class="number">1</span>]</span><br><span class="line">pr_train,re_train,thre_train = metrics.precision_recall_curve(train_y,predict_train)</span><br><span class="line">pr_test,re_test,thre_test = metrics.precision_recall_curve(test_y,predict_test)</span><br><span class="line">auc_train = metrics.roc_auc_score(train_y,predict_train)</span><br><span class="line">auc_test = metrics.roc_auc_score(test_y,predict_test)</span><br><span class="line">prt_train = pd.DataFrame(&#123;<span class="string">&#x27;precision&#x27;</span>:pr_train,<span class="string">&#x27;recall&#x27;</span>:re_train&#125;)</span><br><span class="line">prt_test = pd.DataFrame(&#123;<span class="string">&#x27;precision&#x27;</span>:pr_test,<span class="string">&#x27;recall&#x27;</span>:re_test&#125;)</span><br><span class="line">print(<span class="string">&#x27;precision&gt;=0.97时对应的最大recall为：&#x27;</span>)</span><br><span class="line">print(prt_test.loc[prt_test[<span class="string">&#x27;precision&#x27;</span>]&gt;=<span class="number">0.97</span>,<span class="string">&#x27;recall&#x27;</span>].<span class="built_in">max</span>())</span><br><span class="line">print(<span class="string">&#x27;auc得分为：&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(auc_test))</span><br></pre></td></tr></table></figure>
<p>precision&gt;=0.97时对应的最大recall为：<br>0.6566275639224501<br>auc得分为：0.9616994012330063</p>
<p>根据上述结果可知，xgboost的训练效果最好，当precision&gt;=0.97时，recall最大能达到74.4%。</p>
<h4 id="2-3-3-重要特征"><a href="#2-3-3-重要特征" class="headerlink" title="2.3.3 重要特征"></a>2.3.3 重要特征</h4><p>使用XGBoost. plot_importance</p>
<img src="../images/18.png"  />

<p>部分重要特征解释：</p>
<table>
<thead>
<tr>
<th><strong>特征</strong></th>
<th><strong>解释</strong></th>
<th>维度</th>
<th>分析</th>
</tr>
</thead>
<tbody><tr>
<td>lastpvgap</td>
<td>一年内距上次访问时长</td>
<td>用户</td>
<td>用户是否活跃</td>
</tr>
<tr>
<td>visitnum_oneyear</td>
<td>年访问次数</td>
<td>用户</td>
<td>用户是否活跃</td>
</tr>
<tr>
<td>cityuvs</td>
<td>昨日访问当前城市同入住日期的app  uv数</td>
<td>用户</td>
<td>用户是否流失到别的平台</td>
</tr>
<tr>
<td>sid</td>
<td>会话id，sid=1可认为是新访</td>
<td>用户</td>
<td>新老用户</td>
</tr>
<tr>
<td>lasthtlordergap</td>
<td>一年内距离上次下单时长</td>
<td>订单</td>
<td>用户是否活跃</td>
</tr>
<tr>
<td>ctrip_profits</td>
<td>客户价值</td>
<td>用户</td>
<td>用户价值越高越不容易流失，反之亦然</td>
</tr>
<tr>
<td>uv_pre</td>
<td>24小时历史浏览次数最多酒店历史uv</td>
<td>酒店</td>
<td>用户偏好的酒店的热度</td>
</tr>
<tr>
<td>h</td>
<td>访问时间点</td>
<td>订单</td>
<td>用户是否活跃</td>
</tr>
<tr>
<td>lowestprice_pre</td>
<td>24小时内已访问次数最多酒店可订最低价</td>
<td>酒店</td>
<td>用户偏好的酒店价格</td>
</tr>
<tr>
<td>jd_people_max</td>
<td>酒店点评浏览</td>
<td>酒店</td>
<td>对于预订网站，<strong>评价</strong>是影响用户做决定的重要因素</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>个人项目</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
        <tag>机器学习</tag>
        <tag>特征工程</tag>
      </tags>
  </entry>
</search>
